Index: PythonCode/MultitaskProgramming/TheCoroutines/TheCoroutines_gevent_monkey.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/MultitaskProgramming/TheCoroutines/TheCoroutines_gevent_monkey.py	(date 1591954770514)
+++ PythonCode/MultitaskProgramming/TheCoroutines/TheCoroutines_gevent_monkey.py	(date 1591954770514)
@@ -0,0 +1,19 @@
+from gevent import monkey
+import gevent
+import random
+import time
+
+monkey.patch_all()
+
+
+def coroutine_work(coroutine_name):
+    for i in range(10):
+        print(coroutine_name, i)
+        time.sleep(random.random())
+
+
+gevent.joinall([gevent.spawn(coroutine_work, "work1"),
+                gevent.spawn(coroutine_work, "work2")
+                ])
+
+
Index: PythonCode/MultitaskProgramming/TheCoroutines/ScrapySelector.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/MultitaskProgramming/TheCoroutines/ScrapySelector.py	(date 1591956652138)
+++ PythonCode/MultitaskProgramming/TheCoroutines/ScrapySelector.py	(date 1591956652138)
@@ -0,0 +1,17 @@
+import requests
+from scrapy import Selector
+
+
+def get_page_items(*, start_page_num: int=1, end_page_num: int=2, step: int=1):
+    items = []
+    for page_num in range(start_page_num, end_page_num, step):
+        base_url = 'https://www.xiuaa.com/qcmn/2062_1.html'
+        req = requests.get(base_url.format(genre='cute', page_num=1))
+        content = req.content.decode('gbk')
+        selector = Selector(text=content)
+        item_urls = list(set(selector.css('#maincontent a::attr(href)').extract()))
+        items.extend(url for url in item_urls if url.startswith('https://www.xiuaa.com/qcmn/'))
+    return items
+
+
+print(get_page_items())
Index: PythonCode/MultitaskProgramming/TheCoroutines/Scrapy_Selector.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/MultitaskProgramming/TheCoroutines/Scrapy_Selector.py	(date 1591956099441)
+++ PythonCode/MultitaskProgramming/TheCoroutines/Scrapy_Selector.py	(date 1591956099441)
@@ -0,0 +1,26 @@
+import requests
+from scrapy import Selector
+
+
+def get_page_items(*, start_page_num: int=1, end_page_num: int=2, step: int=1):
+    items = []
+    for page_num in range(start_page_num, end_page_num, step):
+        base_url = 'http://www.meizitu.com/a/{genre}_{page_num}.html'
+        req = requests.get(base_url.format(genre='cute', page_num=1))
+        content = req.content.decode('gbk')
+        selector = Selector(text=content)
+        item_urls = list(set(selector.css('#maincontent a::attr(href)').extract()))
+        items.extend(url for url in item_urls if url.startswith('http://www.meizitu.com/a/'))
+    return items
+
+
+def get_images(item):
+    req = requests.get(item)
+    content = req.content.decode('gbk')
+    selector = Selector(text=content)
+    image_urls = list(set(selector.css('#maincontent p img::attr(src)').extract()))
+    print(image_urls)
+
+
+for item in get_page_items():
+    get_images(item)
\ No newline at end of file
Index: PythonCode/MultitaskProgramming/TheCoroutines/TheCoroutines_gevent.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/MultitaskProgramming/TheCoroutines/TheCoroutines_gevent.py	(date 1591954594701)
+++ PythonCode/MultitaskProgramming/TheCoroutines/TheCoroutines_gevent.py	(date 1591954594701)
@@ -0,0 +1,15 @@
+import gevent
+
+
+def f(n):
+    for i in range(n):
+        print(gevent.getcurrent(), i)
+
+
+g1 = gevent.spawn(f, 5)
+g2 = gevent.spawn(f, 5)
+g3 = gevent.spawn(f, 5)
+g1.join()
+g2.join()
+g3.join()
+
Index: PythonCode/MultitaskProgramming/TheCoroutines/TheCoroutines.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/MultitaskProgramming/TheCoroutines/TheCoroutines.py	(date 1591953719044)
+++ PythonCode/MultitaskProgramming/TheCoroutines/TheCoroutines.py	(date 1591953719044)
@@ -0,0 +1,29 @@
+# -*- coding=utf-8 -*-
+
+import time
+
+
+def work1():
+    while True:
+        print("--A--")
+        yield
+        time.sleep(0.5)
+
+
+def work2():
+    while True:
+        print("--B--")
+        yield
+        time.sleep(0.5)
+
+
+def main():
+    w1 = work1()
+    w2 = work2()
+    while True:
+        next(w1)
+        next(w2)
+
+
+if __name__ == '__main__':
+    main()
Index: PythonCode/MultitaskProgramming/TheCoroutines/ConcurrentDownload.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/MultitaskProgramming/TheCoroutines/ConcurrentDownload.py	(date 1592109140247)
+++ PythonCode/MultitaskProgramming/TheCoroutines/ConcurrentDownload.py	(date 1592109140247)
@@ -0,0 +1,41 @@
+from gevent import monkey
+import gevent
+import urllib.request
+
+# 有耗时操作时需要
+monkey.patch_all()
+
+def my_downLoad(url):
+    print('GET: %s' % url)
+    resp = urllib.request.urlopen(url)
+    data = resp.read()
+    print('%d bytes received from %s.' % (len(data), url))
+
+gevent.joinall([
+        gevent.spawn(my_downLoad, 'http://www.baidu.com/'),
+        gevent.spawn(my_downLoad, 'http://www.itcast.cn/'),
+        gevent.spawn(my_downLoad, 'http://www.itheima.com/'),
+])
+
+from gevent import monkey
+import gevent
+import urllib.request
+
+#有IO才做时需要这一句
+monkey.patch_all()
+
+def my_downLoad(file_name, url):
+    print('GET: %s' % url)
+    resp = urllib.request.urlopen(url)
+    data = resp.read()
+
+    with open(file_name, "wb") as f:
+        f.write(data)
+
+    print('%d bytes received from %s.' % (len(data), url))
+
+gevent.joinall([
+        gevent.spawn(my_downLoad, "1.mp4", 'http://oo52bgdsl.bkt.clouddn.com/05day-08-%E3%80%90%E7%90%86%E8%A7%A3%E3%80%91%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89.mp4'),
+        gevent.spawn(my_downLoad, "2.mp4", 'http://oo52bgdsl.bkt.clouddn.com/05day-03-%E3%80%90%E6%8E%8C%E6%8F%A1%E3%80%91%E6%97%A0%E5%8F%82%E6%95%B0%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E8%B0%83%E7%94%A8%28%E4%B8%8B%29.mp4'),
+])
+
Index: PythonCode/MultitaskProgramming/TheCoroutines/TheCoroutines_greenlet.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/MultitaskProgramming/TheCoroutines/TheCoroutines_greenlet.py	(date 1591953719123)
+++ PythonCode/MultitaskProgramming/TheCoroutines/TheCoroutines_greenlet.py	(date 1591953719123)
@@ -0,0 +1,23 @@
+# -*- coding=utf-8 -*-
+
+from greenlet import greenlet
+import time
+
+
+def test1():
+    while True:
+        print("--A-")
+        gr2.switch()
+        time.sleep(0.5)
+
+
+def tets2():
+    while True:
+        print("--B-")
+        gr1.switch()
+        time.sleep(0.5)
+
+
+gr1 = greenlet(test1)
+gr2 = greenlet(tets2)
+gr1.switch()
Index: PythonCode/DataStructureAlgorithm/Interview.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DataStructureAlgorithm/Interview.py	(date 1593419377405)
+++ PythonCode/DataStructureAlgorithm/Interview.py	(date 1593419377405)
@@ -0,0 +1,77 @@
+"""
+1、青蛙跳台阶问题
+一只青蛙要跳上 n 层高的台阶，一次能跳一级，也可以跳两级，请问这只青蛙有多少种跳上这个 n
+层高台阶的方法？
+思路分析：
+方法 1:递归
+设青蛙跳上 n 级台阶有 f(n)种方法，把这 n 种方法分为两大类，第一种最后一次跳了一级台阶，这
+类方法共有 f(n-1)种，第二种最后一次跳了两级台阶，这种方法共有 f(n-2)种，则得出递推公式
+f(n)=f(n-1)+f(n-2)，显然，f(1)=1，f(2)=2，递推公式如下：
+* 这种方法虽然代码简单，但效率低，会超出时间上限*
+代码实现如下：
+"""
+
+
+class Solution(object):
+    # @param:{integer} n
+    # @return:{integer}
+    def climbStairs(self, n):
+        if n == 1 or n == 2:
+            return n
+        else:
+            return self.climbStairs(n - 1) + self.climbStairs(n - 2)
+
+
+class Solution2(object):
+    # @param:{integer} n
+    # @return:{integer}
+    def climbStairs(self, n):
+        if n == 1 or n == 2:
+            return n
+        a, b, c = 1, 2, 3
+        for i in range(3, n + 1):
+            c = a + b
+            a = b
+            b = c
+        return c
+
+
+class Solution3(object):
+    def climbStairs(self, n):
+        def fact(n):
+            result = 1
+            for i in range(1, n + 1):
+                result *= i
+            return result
+
+        total = 0
+        for i in range(int(n / 2 + 1)):
+            total += int(fact(i + n - 2 * i) / fact(i) / fact(n - 2 * i))
+        return total
+
+
+class Solution4(object):
+    # @param n, an integer
+    # @return an integer
+    def climbStairs(self, n):
+        if n <= 1:
+            return 1
+        arr = [1, 1, 0]  # look here, arr[0] = 1, arr[1] = 2
+        for i in range(2, n + 1):
+            arr[2] = arr[0] + arr[1]
+            arr[0], arr[1] = arr[1], arr[2]
+        return arr[2]
+
+
+if __name__ == "__main__":
+    # a = Solution()
+    # b = a.climbStairs(10)
+    # print(b)
+
+    # a = Solution2()
+    # c = a.climbStairs(10)
+    # print(c)
+
+    a = Solution3()
+    c = a.climbStairs(10)
+    print(c)
Index: PythonCode/DataStructureAlgorithm/Stack/Stack.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DataStructureAlgorithm/Stack/Stack.py	(date 1591866946643)
+++ PythonCode/DataStructureAlgorithm/Stack/Stack.py	(date 1591866946643)
@@ -0,0 +1,32 @@
+# encoding:utf-8
+
+"""栈"""
+
+
+class Stack(object):
+    def __init__(self):
+        self.__items = []
+        # self.__items = SingleLinkList()  # 单链表
+
+    def push(self, item):
+        """添加一个新的元素item到栈顶"""
+        self.__items.append(item)  # O(1)
+        # self.__items.insert(0, item)  # O(n)
+
+    def pop(self):
+        """弹出栈元素"""
+        # self.__items.pop(0)   # O(n)
+        return self.__items.pop()  # O(1)
+
+    def peek(self):
+        """返回栈顶元素"""
+        return self.__items[-1]
+        # return self.__items[len(self.__items) - 1]  # O(n)
+
+    def is__empty(self):
+        """判断栈是否为空"""
+        return self.__items == []
+
+    def size(self):
+        """返回栈的个数"""
+        return len(self.__items)
\ No newline at end of file
Index: PythonCode/DataStructureAlgorithm/LinkList/DoubleLinkList.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DataStructureAlgorithm/LinkList/DoubleLinkList.py	(date 1591866946577)
+++ PythonCode/DataStructureAlgorithm/LinkList/DoubleLinkList.py	(date 1591866946577)
@@ -0,0 +1,148 @@
+# encoding:utf-8
+
+"""双向链表"""
+
+
+class Node(object):
+    """结点类"""
+
+    def __init__(self, item):
+        self.item = item
+        self.next = None
+        self.pre = None
+
+
+class DoubleLinkList(object):
+    """双向链表"""
+
+    def __init__(self, node=None):
+        self.__head = node
+
+    def is_etmy(self):
+        """链表是否为空
+        :return 如果链表为空，则返回真
+        """
+        return self.__head is None
+
+    def length(self):
+        """链表长度"""
+        cur = self.__head
+        count = 0
+        while cur is not None:
+            count += 1
+            cur = cur.next
+        return count
+
+    def travel(self):
+        """遍历整个链表"""
+        cur = self.__head
+        while cur is not None:
+            print(cur.item, end=" ")
+            cur = cur.next
+        print("")
+
+    def search(self, item):
+        """查找结点是否存在"""
+        cur = self.__head
+        while cur is not None:
+            if cur.item == item:
+                return True
+            cur = cur.next
+        return False
+
+    def add(self, item):
+        """链表头部添加元素
+        ：:param item:要保存的具体数据
+        """
+        node = Node(item)
+        node.next = self.__head
+        self.__head = node
+        if node.next:
+            node.next.pre = node
+
+    def append(self, item):
+        """链表尾部添加元素"""
+        node = Node(item)
+        # 如果链表为空，需要进行特殊处理
+        if self.is_etmy():
+            self.__head = node
+        else:
+            cur = self.__head
+            while cur.next is not None:
+                cur = cur.next
+            # 退出结尾的时候，cur指向的尾结点
+            node.pre = cur
+            cur.next = node
+
+    def insert(self, pos, item):
+        """指定位置添加元素"""
+        # 在头部添加元素
+        if pos <= 0:
+            self.add(item)
+        # 在尾部添加元素
+        elif pos >= self.length():
+            self.append(item)
+        # 中部添加
+        else:
+            cur = self.__head
+            count = 0
+            while count < pos:
+                count += 1
+                cur = cur.next
+            # 退出循环时，cur指向pos位置
+            node = Node(item)
+            node.next = cur
+            node.pre = cur.pre
+            cur.pre.next = node
+            cur.pre = node
+
+    def remove(self, item):
+        """删除节点"""
+        cur = self.__head
+        while cur is not None:
+            # 找到了要删除的元素
+            if cur.item == item:
+                # 在头部找到了要删除的元素
+                if cur == self.__head:
+                    self.__head = cur.next
+                    # 链表并不只有一个节点：（self.___head & cur.next）
+                    # if self.__head:
+                    if cur.next:
+                        self.__head.pre = None
+                else:
+                    cur.pre.next = cur.next
+                    if cur.next:
+                        cur.next.pre = cur.pre
+                return
+            # 不是要找的元素，移动游标
+            pre = cur
+            cur = cur.next
+
+
+if __name__ == "__main__":
+    list0 = DoubleLinkList()
+    print(list0.length())
+    list0.travel()
+    list0.append(1)
+    print(list0.length())
+    list0.travel()
+    list0.append(2)
+    print(list0.travel())
+    list0.add(3)
+    print(list0.travel())
+    list0.add(4)
+    print(list0.travel())
+    list0.append(5)
+    print(list0.travel())
+    list0.insert(2, 6)
+    print(list0.travel())
+    list0.remove(4)
+    print(list0.travel())
+    list0.remove(5)
+    print(list0.travel())
+    list0.remove(6)
+    print(list0.travel())
+    list0.remove(3)
+    print(list0.travel())
+    list0.remove(2)
+    print(list0.travel())
\ No newline at end of file
Index: PythonCode/DataStructureAlgorithm/LinkList/CycleSingLinkList.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DataStructureAlgorithm/LinkList/CycleSingLinkList.py	(date 1591866946593)
+++ PythonCode/DataStructureAlgorithm/LinkList/CycleSingLinkList.py	(date 1591866946593)
@@ -0,0 +1,185 @@
+# encoding:utf-8
+
+"""单向循环链表"""
+
+
+class Node(object):
+    """结点类"""
+
+    def __init__(self, item):
+        self.item = item
+        self.next = None
+
+
+class CycleSingLinkList(object):
+    """单向循环链表"""
+
+    def __init__(self, node=None):
+        self.__head = node
+
+    def is_empty(self):
+        """链表是否为空
+        :return 如果链表为空，则返回真
+        """
+        return self.__head is None
+
+    def length(self):
+        """链表长度"""
+        if self.is_empty():
+            return 0
+        cur = self.__head
+        count = 1
+        while cur.next != self.__head:
+            count += 1
+            cur = cur.next
+        return count
+
+    def travel(self):
+        """遍历整个链表"""
+        if self.is_empty():
+            print("")
+            return
+        cur = self.__head
+        while cur.next != self.__head:
+            print(cur.item, end=" ")
+            cur = cur.next
+        # 从循环退出，cur指向尾节点
+        print(cur.item)
+
+    def add(self, item):
+        """链表头部添加元素
+        ：:param item:要保存的具体数据
+        """
+        node = Node(item)
+        if self.is_empty():
+            self.__head = node
+            node.next = self.__head
+        #  寻找尾结点
+        cur = self.__head
+        while cur.next != self.__head:
+            cur = cur.next
+        # 从循环退出，cur指向尾结点
+        node.next = self.__head
+        self.__head = node
+        cur.next = self.__head
+
+    def append(self, item):
+        """链表尾部添加元素"""
+        node = Node(item)
+        # 如果链表为空，需要进行特殊处理
+        if self.is_empty():
+            self.__head = node
+            node.next = node
+        else:
+            cur = self.__head
+            while cur.next != self.__head:
+                cur = cur.next
+            # 退出结尾的时候，cur指向的尾结点
+            cur.next = node
+            node.next = self.__head
+
+    def insert(self, pos, item):
+        """指定位置添加元素"""
+        # 在头部添加元素
+        if pos <= 0:
+            self.add(item)
+        # 在尾部添加元素
+        elif pos >= self.length():
+            self.append(item)
+        # 中部添加
+        else:
+            cur = self.__head
+            count = 0
+            while count < (pos - 1):
+                count += 1
+                cur = cur.next
+            # 退出循环时，cur指向pos的前一个位置
+            node = Node(item)
+            node.next = cur.next
+            cur.next = node
+
+    def remove(self, item):
+        """删除节点"""
+        if self.is_empty():
+            return
+        cur = self.__head
+        pre = None
+        while cur.next != self.__head:
+            # 找到了要删除的元素
+            if cur.item == item:
+                # 在头部找到了要删除的元素
+                if cur == self.__head:
+                    # 需要先找尾结点
+                    rear = self.__head
+                    while rear.next != self.__head:
+                        # rear循环
+                        rear = rear.next
+                    # rear为尾结点时退出循环
+                    self.__head = cur.next  # 先确定头结点
+                    rear.next = self.__head
+                else:
+                    pre.next = cur.next
+                    return
+            # 不是要找的元素，移动游标
+            pre = cur
+            cur = cur.next
+        # 退出循环后，cur指向尾结点
+        if cur.item == item:
+            # 如果链表只有一个节点
+            if cur == self.__head:
+                self.__head = None
+            else:
+                pre.next = self.__head
+
+    def search(self, item):
+        """查找元素, 结点是否存在"""
+        if self.is_empty():
+            return False
+        cur = self.__head
+        while cur.next != self.__head:
+            if cur.item == item:
+                return True
+            cur = cur.next
+        # 退出循环后，cur指向尾结点（cur.next == self.__head）
+        if cur.item == item:
+            return True
+        return False
+
+
+if __name__ == "__main__":
+    list0 = CycleSingLinkList()
+    print(list0.length())
+    list0.travel()
+    list0.append(1)  # 1
+    print(list0.length())
+    list0.travel()
+
+    list0.append(2)  # 1,2
+    print(list0.travel())
+
+    list0.add(3)  # 3,1,2
+    print(list0.travel())
+
+    list0.insert(0, 4)  # 4,3,1,2
+    print(list0.travel())
+
+    list0.insert(11, 5)  # 4,3,1,2,5
+    print(list0.travel())
+
+    list0.insert(2, 6)  # 4,3,6,1,2,5
+    print(list0.travel())
+
+    list0.remove(4)  # 3,6,1,2,5
+    print(list0.travel())
+
+    list0.remove(5)  # 3,6,1,2
+    print(list0.travel())
+
+    list0.remove(6)  # 3,1,2
+    print(list0.travel())
+
+    list0.remove(3)  # 1,2
+    print(list0.travel())
+
+    list0.remove(2)  # 1
+    print(list0.travel())
\ No newline at end of file
Index: PythonCode/DataStructureAlgorithm/LinkList/SingleLinkList.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DataStructureAlgorithm/LinkList/SingleLinkList.py	(date 1591866946651)
+++ PythonCode/DataStructureAlgorithm/LinkList/SingleLinkList.py	(date 1591866946651)
@@ -0,0 +1,137 @@
+# encoding:utf-8
+
+"""单链表"""
+
+
+class Node(object):
+    """结点类"""
+
+    def __init__(self, item):
+        self.item = item
+        self.next = None
+
+
+class SingleLinkList(object):
+    """单链表"""
+
+    def __init__(self, node=None):
+        self.__head = node
+
+    def is_etmy(self):
+        """链表是否为空
+        :return 如果链表为空，则返回真
+        """
+        return self.__head is None
+
+    def length(self):
+        """链表长度"""
+        cur = self.__head
+        count = 0
+        while cur is not None:
+            count += 1
+            cur = cur.next
+        return count
+
+    def travel(self):
+        """遍历整个链表"""
+        cur = self.__head
+        while cur is not None:
+            print(cur.item, end=" ")
+            cur = cur.next
+        print("")
+
+    def add(self, item):
+        """链表头部添加元素
+        ：:param item:要保存的具体数据
+        """
+        node = Node(item)
+        node.next = self.__head
+        self.__head = node
+
+    def append(self, item):
+        """链表尾部添加元素"""
+        node = Node(item)
+        # 如果链表为空，需要进行特殊处理
+        if self.is_etmy():
+            self.__head = node
+        else:
+            cur = self.__head
+            while cur.next is not None:
+                cur = cur.next
+            # 退出结尾的时候，cur指向的尾结点
+            cur.next = node
+
+    def insert(self, pos, item):
+        """指定位置添加元素"""
+        # 在头部添加元素
+        if pos <= 0:
+            self.add(item)
+        # 在尾部添加元素
+        elif pos >= self.length():
+            self.append(item)
+        # 中部添加
+        else:
+            cur = self.__head
+            count = 0
+            while count < (pos - 1):
+                count += 1
+                cur = cur.next
+            # 退出循环时，cur指向post的前一个位置
+            node = Node(item)
+            node.next = cur.next
+            cur.next = node
+
+    def remove(self, item):
+        """删除节点"""
+        cur = self.__head
+        pre = None
+        while cur is not None:
+            # 找到了要删除的元素
+            if cur.item == item:
+                # 在头部找到了要删除的元素
+                if cur == self.__head:
+                    self.__head = cur.next
+                else:
+                    pre.next = cur.next
+                    return
+            # 不是要找的元素，移动游标
+            pre = cur
+            cur = cur.next
+
+    def search(self, item):
+        """查找元素"""
+        cur = self.__head
+        while cur is not None:
+            if cur.item == item:
+                return True
+            cur = cur.next
+        return False
+
+
+if __name__ == "__main__":
+    list0 = SingleLinkList()
+    print(list0.length())
+    list0.travel()
+    list0.append(1)
+    print(list0.length())
+    list0.travel()
+    list0.append(2)
+    print(list0.travel())
+    list0.add(3)
+    print(list0.travel())
+    list0.add(4)
+    print(list0.travel())
+    list0.append(5)
+    print(list0.travel())
+    list0.insert(2, 6)
+    print(list0.travel())
+    list0.remove(4)
+    print(list0.travel())
+    list0.remove(5)
+    print(list0.travel())
+    list0.remove(6)
+    print(list0.travel())
+    list0.remove(3)
+    print(list0.travel())
+    list0.remove(2)
+    print(list0.travel())
Index: PythonCode/DataStructureAlgorithm/Algorithm/AlgorithmTime.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DataStructureAlgorithm/Algorithm/AlgorithmTime.py	(date 1591867740861)
+++ PythonCode/DataStructureAlgorithm/Algorithm/AlgorithmTime.py	(date 1591867740861)
@@ -0,0 +1,266 @@
+# encoding:utf-8
+
+"""排序算法用时比较"""
+# -*- coding: UTF-8 -*-
+# Space:https://github.com/Tri-x/exercise
+# Space:https://space.bilibili.com/187492698
+# Author:Trix
+# Description:排序算法
+# Python的排序算法用的是Time Sort 一种源自归并排序和插入排序的稳定高效的排序算法
+
+from random import randint  # 随机整数
+from time import process_time  # 计时
+
+nums_lists = [[] for n in range(4)]  # 随机创建四个无序数列，用来粗略地测试每种排序算法的用时
+for n in range(500):  # 数列长度为500
+    nums_lists[0].append(randint(-400, 400))  # 随机范围：（-400, 400）
+for n in range(1000):
+    nums_lists[1].append(randint(-8000, 8000))
+for n in range(5001):
+    nums_lists[2].append(randint(-2000, 2000))
+for n in range(10000):
+    nums_lists[3].append(randint(-9000, 9000))
+
+
+def bubble_sort(num_list):  # 冒泡排序
+    for i in range(len(num_list) - 1):
+        for j in range(len(num_list) - 1 - i):
+            if num_list[j] > num_list[j + 1]:
+                num_list[j], num_list[j + 1] = num_list[j + 1], num_list[j]
+    return num_list
+
+
+def select_sort(num_list):  # 选择排序
+    for i in range(len(num_list) - 1):
+        min_index = i
+        for j in range(i, len(num_list)):
+            if num_list[j] < num_list[min_index]:
+                num_list[min_index], num_list[j] = num_list[j], num_list[min_index]
+    return num_list
+
+
+def insert_sort(num_list):  # 插入排序
+    for i in range(1, len(num_list) + 1):
+        for j in range(i):
+            if i < len(num_list):
+                if num_list[i] <= num_list[j]:
+                    num_list[i], num_list[j] = num_list[j], num_list[i]
+    return num_list
+
+
+def shell__sort(num_list):
+    gap = len(num_list) // 2
+    while gap >= 1:
+        for j in range(gap, len(num_list)):
+            while (j - gap) >= 0:
+                if num_list[j] < num_list[j - gap]:
+                    num_list[j], num_list[j - gap] = num_list[j - gap], num_list[j]
+                    j -= gap
+                else:
+                    break
+        gap //= 2
+    return num_list
+
+
+def merge_sort(num_list):  # 归并排序
+    if len(num_list) <= 1:
+        return num_list
+    middle = len(num_list) // 2
+    list_before = merge_sort(num_list[:middle])
+    list_after = merge_sort(num_list[middle:])
+    return merge_compare(list_before, list_after)
+
+
+def merge_compare(list_before, list_after):
+    result_list = []
+    before_index = after_index = 0
+    while before_index < len(list_before) and after_index < len(list_after):
+        if list_before[before_index] < list_after[after_index]:
+            result_list.append(list_before[before_index])
+            before_index += 1
+        elif list_after[after_index] <= list_before[before_index]:
+            result_list.append(list_after[after_index])
+            after_index += 1
+    if before_index == len(list_before):
+        for i in list_after[after_index:]:
+            result_list.append(i)
+    elif after_index == len(list_after):
+        for i in list_before[before_index:]:
+            result_list.append(i)
+    return result_list
+
+
+def quick_sort(num_list):  # 快速排序
+    quick_recursion(num_list, 0, len(num_list) - 1)
+
+
+def quick_recursion(num_list, head_index, tail_index):
+    if head_index < tail_index:
+        pivot_index = quick_partition(num_list, head_index, tail_index)
+        quick_recursion(num_list, head_index, pivot_index - 1)
+        quick_recursion(num_list, pivot_index + 1, tail_index)
+    return num_list
+
+
+def quick_partition(num_list, head_index, tail_index):
+    pivot = num_list[tail_index]
+    exchange_index = head_index - 1
+    for i in range(head_index, tail_index):
+        if num_list[i] < pivot:
+            exchange_index += 1
+            num_list[exchange_index], num_list[i] = num_list[i], num_list[exchange_index]
+    num_list[exchange_index + 1], num_list[tail_index] = num_list[tail_index], num_list[exchange_index + 1]
+    return exchange_index + 1
+
+
+def heap_sort(num_list):  # 堆排序
+    list_len = len(num_list)
+    for i in range(list_len // 2, -1, -1):
+        heapify(num_list, list_len, i)
+    for i in range(list_len - 1, 0, -1):
+        num_list[0], num_list[i] = num_list[i], num_list[0]
+        list_len -= 1
+        heapify(num_list, list_len, 0)
+    return num_list
+
+
+def heapify(num_list, list_len, parent_index):
+    left_index = 2 * parent_index + 1
+    right_index = left_index + 1
+    max_index = parent_index
+    if left_index < list_len and num_list[left_index] > num_list[max_index]:
+        max_index = left_index
+    if right_index < list_len and num_list[right_index] > num_list[max_index]:
+        max_index = right_index
+    if max_index != parent_index:
+        num_list[parent_index], num_list[max_index] = num_list[max_index], num_list[parent_index]
+        heapify(num_list, list_len, max_index)
+
+
+def count_sort(num_list):  # 计数排序
+    max_num = max(num_list)
+    min_num = min(num_list)
+    neg_list = []
+    pos_list = []
+    for num in num_list:
+        if num < 0:
+            neg_list.append(num)
+        if num >= 0:
+            pos_list.append(num)
+    if len(neg_list) != 0:
+        neg_counts_list = [0 for i in range(min_num, 0)]
+        for i in range(len(neg_list)):
+            neg_counts_list[neg_list[i]] += 1
+        neg_index = 0
+        for i in range(-len(neg_counts_list), 0):
+            while neg_counts_list[i] > 0:
+                neg_list[neg_index] = i
+                neg_index += 1
+                neg_counts_list[i] -= 1
+    if len(pos_list) != 0:
+        pos_counts_list = [0 for i in range(max_num + 1)]
+        for i in range(len(pos_list)):
+            pos_counts_list[pos_list[i]] += 1
+        pos_index = 0
+        for i in range(len(pos_counts_list)):
+            while pos_counts_list[i] > 0:
+                pos_list[pos_index] = i
+                pos_index += 1
+                pos_counts_list[i] -= 1
+    result_list = neg_list + pos_list
+    return result_list
+
+
+def bucket_sort(num_list):  # 桶排序
+    bucket_list = [0 for i in range(max(num_list) - min(num_list) + 1)]
+    for i in range(len(num_list)):
+        bucket_list[num_list[i] - min(num_list)] += 1
+    result_list = []
+    for i in range(len(bucket_list)):
+        if bucket_list[i] != 0:
+            result_list += [i + min(num_list)] * bucket_list[i]
+    return result_list
+
+
+def radix_sort(num_list):  # 基数排序
+    pos_list = []
+    neg_list = []
+    for num in num_list:
+        if num < 0:
+            neg_list.append(num)
+        if num >= 0:
+            pos_list.append(num)
+    if len(neg_list) != 0:
+        neg_num_digit = 0
+        while neg_num_digit < len(str(min(neg_list))):
+            neg_values_lists = [[] for i in range(10)]
+            for neg_num in neg_list:
+                neg_values_lists[int(neg_num / (10 ** neg_num_digit)) % 10].append(neg_num)
+            neg_list.clear()
+            for neg_value_list in neg_values_lists:
+                for neg_num in neg_value_list:
+                    neg_list.append(neg_num)
+            neg_num_digit += 1
+    if len(pos_list) != 0:
+        pos_num_digit = 0
+        while pos_num_digit < len(str(max(pos_list))):
+            pos_values_lists = [[] for i in range(10)]
+            for pos_num in pos_list:
+                pos_values_lists[int(pos_num / (10 ** pos_num_digit)) % 10].append(pos_num)
+            pos_list.clear()
+            for pos_value_list in pos_values_lists:
+                for pos_num in pos_value_list:
+                    pos_list.append(pos_num)
+            pos_num_digit += 1
+    result_list = neg_list + pos_list
+    return result_list
+
+
+# 记录每一种排序算法对于不同长度无序数列的排序时间
+sorts_time_dict = {
+    bubble_sort: ["Bubble Sort"],  # 冒泡排序
+    select_sort: ["Select Sort"],  # 选择排序
+    insert_sort: ["Insert Sort"],  # 插入排序
+    shell__sort: ["Shell Sort"],  # 希尔排序
+    merge_sort: ["Merge Sort"],  # 归并排序
+    quick_sort: ["Quick Sort"],  # 快速排序
+    heap_sort: ["Heap Sort"],  # 堆排序
+    count_sort: ["Count Sort"],  # 计数排序
+    bucket_sort: ["Bucket Sort"],  # 桶排序
+    radix_sort: ["Radix Sort"]  # 基数排序
+}
+
+for num_list in nums_lists:  # 由于两层for循环会使对数列进行快速排序时递归太深，会引起python崩溃,单独对每个数列进行排序
+    print("正在对第"+str(nums_lists.index(num_list)+1)+"个长为"+str(len(num_list))+"的随机数列执行Quick Sort算法")
+    start_time = process_time()  # 开始计时，计时部分为排序算法
+    quick_sort(num_list)
+    end_time = process_time()  # 结束计时
+    sorts_time_dict[quick_sort].append(end_time - start_time)  # 记录每种排序算法对不同长度数列的排序时间 单位为秒
+for num_list in nums_lists:  # 对每一个数列进行每一种排序算法
+    for func_sort, time_list in sorts_time_dict.items():
+        if func_sort != quick_sort:
+            print("正在对第" + str(nums_lists.index(num_list) + 1) + "个" + "长为"
+                  + str(len(num_list)) + "的随机数列执行" + time_list[0] + "算法", )
+            start_time = process_time()  # 开始计时，计时部分为排序算法
+            func_sort(num_list.copy())  # 排序算法 .copy() 复制品 防止改变原数列
+            end_time = process_time()  # 结束计时
+            time_list.append(end_time - start_time)  # 记录每种排序算法对不同长度数列的排序时间 单位为秒
+print(" ")
+print("十种排序算法对于不同长度的随机无序数列的排序时间结果如下：")
+print("{:20s}{:<15d}{:<15d}{:<15d}{:<15d}".format("Length of Series:", 500, 1000, 5001, 10000))  # 格式化输出
+for time_list in sorts_time_dict.values():  # 每种算法
+    for sort_time in time_list:  # 每种算法的名称和其处理每个数列的时间
+        if not isinstance(sort_time, float):  # 如果use_time类型不为float 即为名称
+            print("{:20s}".format(sort_time + ":"), end=" ")
+        else:
+            print("{:<15.4f}".format(sort_time), end=" ")  # 左对齐，保留四位小数
+    print(" ")
+print("单次随机数列排序时间结果不代表所有")
+print(" ")
+count_sort_list = []  # 因为计数排序太快了，单独创建一个长度为100000的数列来测试排序时间
+for i in range(100000):
+    count_sort_list.append(randint(-80000, 100000))
+start_time_count_sort = process_time()  # 开始计时，计时部分为排序算法
+count_sort(count_sort_list.copy())
+end_time_count_sort = process_time()  # 结束计时
+print("计数排序一个长度为100000的随机数列所用的时间为" + str(round(end_time_count_sort - start_time_count_sort, 3)) + "秒")
Index: PythonCode/DataStructureAlgorithm/Algorithm/ShellSort.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DataStructureAlgorithm/Algorithm/ShellSort.py	(date 1591866946604)
+++ PythonCode/DataStructureAlgorithm/Algorithm/ShellSort.py	(date 1591866946604)
@@ -0,0 +1,25 @@
+# encoding:utf-8
+
+"""希尔排序"""
+
+
+def shell_sort(alist):
+    n = len(alist)
+    gap = n // 2
+    while gap >= 1:
+        for i in range(gap, n):
+            j = i
+            while (j - gap) >= 0:
+                if alist[j] < alist[j - gap]:
+                    alist[j], alist[j - gap] = alist[j - gap], alist[j]
+                    j -= gap
+                else:
+                    break
+        gap //= 2
+
+
+if __name__ == "__main__":
+    blist = [3, 0, 9, 1, 8, 6, 6, 8, 6, 3, 8, 3, 0, 4, 6, 6]
+    print(blist)
+    shell_sort(blist)
+    print(blist)
Index: PythonCode/DataStructureAlgorithm/Algorithm/SelectSort.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DataStructureAlgorithm/Algorithm/SelectSort.py	(date 1591866946534)
+++ PythonCode/DataStructureAlgorithm/Algorithm/SelectSort.py	(date 1591866946534)
@@ -0,0 +1,22 @@
+# encoding:utf-8
+
+
+"""选择排序"""
+
+
+def select_sort(alist):
+    n = len(alist)
+    for i in range(n - 1):
+        min_index = i
+        for j in range(i + 1, n):
+            if alist[j] < alist[min_index]:
+                min_index = j
+        if i != alist[min_index]:
+            alist[i], alist[min_index] = alist[min_index], alist[i]
+
+
+if __name__ == "__main__":
+    blist = [3, 0, 9, 1, 8, 6, 6, 8, 6, 3, 8, 3, 0, 4, 6, 6]
+    print(blist)
+    select_sort(blist)
+    print(blist)
Index: PythonCode/DataStructureAlgorithm/Algorithm/InsertSort.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DataStructureAlgorithm/Algorithm/InsertSort.py	(date 1591866946635)
+++ PythonCode/DataStructureAlgorithm/Algorithm/InsertSort.py	(date 1591866946635)
@@ -0,0 +1,20 @@
+# encoding:utf-8
+
+"""插入排序"""
+
+
+def insert_sort(alist):
+    n = len(alist)
+    for i in range(1, n):
+        for j in range(i, 0, -1):
+            if alist[j] < alist[j - 1]:
+                alist[j], alist[j - 1] = alist[j - 1], alist[j]
+            else:
+                break
+
+
+if __name__ == "__main__":
+    blist = [3, 0, 9, 1, 8, 6, 6, 8, 6, 3, 8, 3, 0, 4, 6, 6]
+    print(blist)
+    insert_sort(blist)
+    print(blist)
Index: PythonCode/DataStructureAlgorithm/Algorithm/QuickSort.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DataStructureAlgorithm/Algorithm/QuickSort.py	(date 1591882019346)
+++ PythonCode/DataStructureAlgorithm/Algorithm/QuickSort.py	(date 1591882019346)
@@ -0,0 +1,63 @@
+# encoding:utf-8
+
+"""快速排序"""
+
+
+def quick__sort(alist, start, end):
+    if start >= end:
+        return
+    mid = alist[start]
+    left = start
+    right = end
+    while left < right:
+        while left < right and alist[right] >= mid:
+            right -= 1
+        alist[left] = alist[right]
+        while left < right and alist[left] < mid:
+            left += 1
+        alist[right] = alist[left]
+    # 退出循环，left与right相遇， 即left==right,获得此轮mid，准备进入下一轮
+    alist[left] = mid
+    # 开启新一轮
+    quick__sort(alist, start, left-1)
+    quick__sort(alist, left+1, end)
+
+
+if __name__ == "__main__":
+    blist = [3, 0, 9, 1, 8, 6, 6, 8, 6, 3, 8, 3, 0, 4, 6, 6]
+    print(blist)
+    quick__sort(blist, 0, len(blist)-1)
+    print(blist)
+
+
+# >---<
+def QuickSort(myList,start,end):
+    #判断low是否小于high,如果为false,直接返回
+    if start < end:
+        i,j = start,end
+        #设置基准数
+        base = myList[i]
+        while i < j:
+            #如果列表后边的数,比基准数大或相等,则前移一位直到有比基准数小的数出现
+            while (i < j) and (myList[j] >= base):
+                j = j - 1
+            #如找到,则把第j个元素赋值给第个元素i,此时表中i,j个元素相等
+            myList[i] = myList[j]
+            #同样的方式比较前半区
+            while (i < j) and (myList[i] <= base):
+                i = i + 1
+            myList[j] = myList[i]
+        #做完第一轮比较之后,列表被分成了两个半区,并且i=j,需要将这个数设置回base
+        myList[i] = base
+        #递归前后半区
+        QuickSort(myList, start, i - 1)
+        QuickSort(myList, j + 1, end)
+    return myList
+
+
+myList = [49, 38, 65, 97, 76, 13, 27, 49]
+print("Quick Sort: ")
+
+QuickSort(myList, 0, len(myList)-1)
+print(myList)
+
Index: PythonCode/DataStructureAlgorithm/Algorithm/MergeSort.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DataStructureAlgorithm/Algorithm/MergeSort.py	(date 1591866946558)
+++ PythonCode/DataStructureAlgorithm/Algorithm/MergeSort.py	(date 1591866946558)
@@ -0,0 +1,34 @@
+# encoding:utf-8
+
+"""归并排序"""
+
+
+def merge_sort(alist):
+    n = len(alist)
+    if 1 == n:
+        return alist
+    mid = n // 2
+    left_sort_list = merge_sort(alist[:mid])
+    right_sort_list = merge_sort(alist[mid:])
+    left, right = 0, 0
+    merge_sort_list = []
+    left_list_n = len(left_sort_list)
+    right_list_n = len(right_sort_list)
+    while left < left_list_n and right < right_list_n:
+        if left_sort_list[left] <= right_sort_list[right]:
+            merge_sort_list.append(left_sort_list[left])
+            left += 1
+        else:
+            merge_sort_list.append(right_sort_list[right])
+            right += 1
+    merge_sort_list += left_sort_list[left:]
+    merge_sort_list += right_sort_list[right:]
+    return merge_sort_list
+
+
+if __name__ == "__main__":
+    blist = [3, 0, 9, 1, 8, 6, 6, 8, 6, 3, 8, 3, 0, 4, 6, 6]
+    print(f"before_alist:{blist}")
+    alist = merge_sort(blist)
+    print(f"after_list:{blist}")
+    print(f"fall_list:{alist}")
Index: PythonCode/DataStructureAlgorithm/Algorithm/BubbleSort.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DataStructureAlgorithm/Algorithm/BubbleSort.py	(date 1591866946539)
+++ PythonCode/DataStructureAlgorithm/Algorithm/BubbleSort.py	(date 1591866946539)
@@ -0,0 +1,23 @@
+# encoding:utf-8
+
+"""冒泡排序"""
+
+
+def bubble__sort(alist):
+    """冒泡排序"""
+    n = len(alist)
+    for i in range(n-1):
+        count = 0
+        for j in range(0, n-1-i):
+            if alist[j] > alist[j+1]:
+                alist[j], alist[j+1] = alist[j+1], alist[j]
+                count += 1
+        if 0 == count:
+            break
+
+
+if __name__ == "__main__":
+    blist = [3, 0, 9, 1, 8, 6, 6, 8, 6, 3, 8, 3, 0, 4, 6, 6]
+    print(blist)
+    bubble__sort(blist)
+    print(blist)
Index: PythonCode/DataStructureAlgorithm/SingLeton/Singleton.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DataStructureAlgorithm/SingLeton/Singleton.py	(date 1591871616152)
+++ PythonCode/DataStructureAlgorithm/SingLeton/Singleton.py	(date 1591871616152)
@@ -0,0 +1,96 @@
+# encoding:utf-8
+
+
+class Singleton(object):
+    __instance = None
+
+    def __new__(cls, *args, **kwargs):
+        if cls.__instance is None:
+            cls.__instance = object.__new__(cls)
+            return cls.__instance
+        else:
+            return cls.__instance
+
+
+if __name__ == "__main__":
+    sing1 = Singleton()
+    sing2 = Singleton(object)
+    print(sing1, sing2)
+
+# ----
+
+
+class Singleton(object):
+    def foo(self):
+        pass
+
+
+singleton_1 = Singleton()
+
+# from a import singleton_1
+
+
+# ----
+
+
+import threading
+
+
+class Singleton(object):
+    _instance_lock = threading.Lock()
+
+    def __init__(self):
+        pass
+
+    def __new__(cls, *args, **kwargs):
+        if not hasattr(Singleton, "_instance"):
+            with Singleton._instance_lock:
+                if not hasattr(Singleton, "_instance"):
+                    Singleton._instance = object.__new__(cls)
+        return Singleton._instance
+
+
+obje1 = Singleton()
+obje2 = Singleton()
+print(obje1, obje2)
+
+
+def task(arg):
+    obj = Singleton()
+    print(obj)
+
+
+for i in range(10):
+    t = threading.Thread(target=task, args=[i, ])
+    t.start()
+
+
+# ---
+
+
+def singleton(cls):
+    __instance = {}
+
+    def __singleton(*args, **kwargs):
+        if cls not in __instance:
+            __instance[cls] = cls(*args, **kwargs)
+        return __instance[cls]
+
+    return __singleton
+
+
+@singleton
+class A(object):
+    a = 1
+
+    def __init__(self, x=0):
+        self.x = x
+
+
+class Singleton(object):
+    def __init__(self):
+        pass
+
+    @classmethod
+    def instance(cls, ):
+        pass
\ No newline at end of file
Index: PythonCode/DataStructureAlgorithm/QueueDeque/Queue.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DataStructureAlgorithm/QueueDeque/Queue.py	(date 1591866946624)
+++ PythonCode/DataStructureAlgorithm/QueueDeque/Queue.py	(date 1591866946624)
@@ -0,0 +1,27 @@
+# encoding:utf-8
+
+
+"""单端队列"""
+
+
+class Queue(object):
+    """单端队列"""
+    def __init__(self):
+        self.__items = []
+
+    def is_empty(self):
+        """是否为空"""
+        return self.__items == []
+
+    def enqueue(self, item):
+        """进队列"""
+        self.__items.insert(0, item)
+
+    def dequeue(self):
+        """出队列"""
+        return self.__items.pop()
+
+    def size(self):
+        """返回大小"""
+        return len(self.__items)
+
Index: PythonCode/DataStructureAlgorithm/QueueDeque/Deque.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DataStructureAlgorithm/QueueDeque/Deque.py	(date 1591866946586)
+++ PythonCode/DataStructureAlgorithm/QueueDeque/Deque.py	(date 1591866946586)
@@ -0,0 +1,33 @@
+# encoding:utf-8
+
+"""双端队列"""
+
+
+class Deque(object):
+    """双端队列"""
+    def __init__(self):
+        self.__items = []
+
+    def is__empty(self):
+        """判断队列是否为空"""
+        return self.__items == []
+
+    def add_front(self, item):
+        """在队列头部添加元素"""
+        self.__items.insert(0, item)
+
+    def add_rear(self, item):
+        """在队列尾部添加元素"""
+        self.__items.append(item)
+
+    def remove_front(self):
+        """从队列头部删除元素"""
+        return self.__items.pop(0)
+
+    def remove_rear(self):
+        """从队列尾部删除元素"""
+        return self.__items.pop()
+
+    def size(self):
+        """返回队列大小"""
+        return len(self.__items)
\ No newline at end of file
Index: PythonCode/DataStructureAlgorithm/BinarySearchTree/BinaryTree.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DataStructureAlgorithm/BinarySearchTree/BinaryTree.py	(date 1591866946615)
+++ PythonCode/DataStructureAlgorithm/BinarySearchTree/BinaryTree.py	(date 1591866946615)
@@ -0,0 +1,96 @@
+# encoding:utf-8
+
+"""二叉树"""
+
+class Node(object):
+    """节点类"""
+    def __init__(self, item):
+        self.item = item
+        self.left_child = None
+        self.right_child = None
+
+
+class BinaryTree(object):
+    """二叉树"""
+    def __init__(self, node=None):
+        self.root = node
+
+    def add(self, item):
+        """
+        广度优先遍历方式添加节点
+        :param item:
+        :return:
+        """
+        if self.root is None:
+            self.root = Node(item)
+        else:
+            queue = [self.root]
+            while len(queue) > 0:
+                node = queue.pop(0)
+                if not node.left_child:
+                    node.left_child = Node(item)
+                    return
+                else:
+                    queue.append(node.left_child)
+                if not node.right_child:
+                    node.right_child = Node(item)
+                    return
+                else:
+                    queue.append(node.right_child)
+
+    def breath_travel(self):
+        """广度优先遍历"""
+        if self.root is None:
+            return
+        else:
+            queue = [self.root]
+            while len(queue) > 0:
+                node = queue.pop(0)
+                print(node.item, end=" ")
+                if node.left_child:
+                    queue.append(node.left_child)
+                if node.right_child:
+                    queue.append(node.right_child)
+
+    def preorder_travel(self, root):
+        """先序 根 左 右"""
+        if root:
+            print(root.item, end=" ")
+            self.preorder_travel(root.left_child)
+            self.preorder_travel(root.right_child)
+
+    def inorder_travel(self, root):
+        """中序 左 根 右"""
+        if root:
+            self.inorder_travel(root.left_child)
+            print(root.item, end=" ")
+            self.inorder_travel(root.right_child)
+
+    def postorder_travel(self, root):
+        """后序 左 右 根"""
+        if root:
+            self.postorder_travel(root.left_child)
+            self.postorder_travel(root.right_child)
+            print(root.item, end=" ")
+
+
+if __name__ == "__main__":
+    node = BinaryTree()
+    node.add(0)
+    node.add(1)
+    node.add(2)
+    node.add(3)
+    node.add(4)
+    node.add(5)
+    node.add(6)
+    node.add(7)
+    node.add(8)
+    node.add(9)
+    node.breath_travel()
+    print(" ")
+    node.preorder_travel(node.root)
+    print(" ")
+    node.inorder_travel(node.root)
+    print(" ")
+    node.postorder_travel(node.root)
+    print(" ")
Index: PythonCode/DataStructureAlgorithm/BinarySearchTree/BinarySearch.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DataStructureAlgorithm/BinarySearchTree/BinarySearch.py	(date 1591866946565)
+++ PythonCode/DataStructureAlgorithm/BinarySearchTree/BinarySearch.py	(date 1591866946565)
@@ -0,0 +1,50 @@
+# encoding:utf-8
+
+"""二分法"""
+
+
+def binary_search(alist, item):
+    """
+    二分查找，递归实现版本
+    :param alist: 查找列表
+    :param time: 查找元素
+    :return: True False
+    """
+    n = len(alist)
+    mid = n // 2
+    if 0 == n:
+        return False
+    if alist[mid] == item:
+        return True
+    if item < alist[mid]:
+        return binary_search(alist[:mid], item)
+    else:
+        return binary_search(alist[mid+1:], item)
+
+
+def binary_search2(alist, item):
+    """
+    二分查找，非递归版本
+    :param alist:
+    :param item:
+    :return: True False
+    """
+    start = 0
+    end = len(alist) - 1
+    while start <= end:
+        mid = (start + end) // 2
+        if alist[mid] == item:
+            return True
+        elif item < alist[mid]:
+            end = mid - 1
+        else:
+            start = mid + 1
+    return False
+
+
+if __name__ == "__main__":
+    blist = [3, 0, 9, 1, 8, 6, 6, 8, 6, 3, 8, 3, 0, 4, 6, 6]
+    print(binary_search(blist, 0))
+    print(binary_search2(blist, 0))
+    print(binary_search(blist, 31))
+    print(binary_search2(blist, 31))
Index: PythonCode/DataStructureAlgorithm/TimeSpaceComplexity/TimeComplexity.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DataStructureAlgorithm/TimeSpaceComplexity/TimeComplexity.py	(date 1591866946608)
+++ PythonCode/DataStructureAlgorithm/TimeSpaceComplexity/TimeComplexity.py	(date 1591866946608)
@@ -0,0 +1,52 @@
+# encoding:utf-8
+
+"""开启"""
+
+import time
+start_time = time.time()
+for a in range(1001):
+    for b in range(1001):
+        c = 1000 - a - b
+        if a**2 + b**2 == c**2:
+            print(f"a:{a}, b:{b}, c:{c}")
+end_time = time.time()
+cost_time = end_time - start_time
+print(f"cost_time:{cost_time}")
+
+
+"""时间复杂度"""
+
+import timeit
+def t1():
+    list1 = []
+    for i in range(5001):
+        list1.append(i)
+
+def t2():
+    list2 = []
+    for i in range(5001):
+        list2.insert(0, i)
+
+def t3():
+    list3 = []
+    for i in range(5001):
+        list3 = list3 + [i]
+
+def t4():
+    list4 = [i for i in range(5001)]
+
+def t5():
+    list5 = list(range(5001))
+
+
+timer1 = timeit.Timer("t1()", "from __main__ import t1")
+timer2 = timeit.Timer("t2()", "from __main__ import t2")
+timer3 = timeit.Timer("t3()", "from __main__ import t3")
+timer4 = timeit.Timer("t4()", "from __main__ import t4")
+timer5 = timeit.Timer("t5()", "from __main__ import t5")
+
+print(f"append:{timer1.timeit(number=100)}")
+print(f"insert:{timer2.timeit(number=100)}")
+print(f"[] + []:{timer3.timeit(number=100)}")
+print(f"[x for x in range(n)]:{timer4.timeit(number=100)}")
+print(f"list():{timer5.timeit(number=100)}")
Index: PythonCode/DecoratorGeneratorIterator/Decorator/Decorator.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DecoratorGeneratorIterator/Decorator/Decorator.py	(date 1591886504335)
+++ PythonCode/DecoratorGeneratorIterator/Decorator/Decorator.py	(date 1591886504335)
@@ -0,0 +1,78 @@
+
+import time
+import functools
+
+
+def logging(level):
+    def func(foo):
+        def wrapper(*args, **kwargs):
+            start = time.time()
+            print("[{level}]:enter function {foo}()".format(level=level, foo=foo.__name__))
+            print(foo(*args, **kwargs))
+            end = time.time()
+            result = end - start
+            return f"共计：{result}秒"
+        return wrapper
+    return func
+
+
+@logging(level="INFO")
+def foo(*args, **kwargs):
+    num = functools.reduce(lambda i, j: i + j, range(100001))
+    return num
+
+
+@logging(level="DEBUG")
+def do(something):
+    print("do {}>>>".format(something))
+
+
+if __name__ == "__main__":
+    foo("hello")
+    do("my work")
+    logging("INFO")
+
+
+# 类装饰器
+
+
+class Logging(object):
+    def __init__(self, level="INFO"):
+        self.level = level
+
+    def __call__(self, func):
+        def wapper(*args, **kwargs):
+            start = time.time()
+            print(func())
+            end = time.time()
+            result = end - start
+            print(f"共计{result}秒")
+
+        return wapper
+
+
+@Logging(level="INFO")
+def sun(*args, **kwargs):
+    num = functools.reduce(lambda i, j: i + j, range(1000001))
+    return num
+
+
+if __name__ == "__main__":
+    sun()
+
+
+import time
+
+
+def timeit(func):
+    def wrapper():
+        start = time.clock()
+        func()
+        end = time.clock()
+        print("used:", end-start)
+        return wrapper
+
+
+@timeit
+def foo():
+    print("in foo()", foo())
\ No newline at end of file
Index: PythonCode/DecoratorGeneratorIterator/TheGenerator/TheGenerator.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/DecoratorGeneratorIterator/TheGenerator/TheGenerator.py	(date 1591894770159)
+++ PythonCode/DecoratorGeneratorIterator/TheGenerator/TheGenerator.py	(date 1591894770159)
@@ -0,0 +1,74 @@
+# 生成器
+
+# <class 'generator'>
+x = (x for x in range(10))
+print(f"{x}\n{type(x)}")
+
+
+# # create a generator
+def createGenerator():
+    mylist = range(4)
+    for i in mylist:
+        yield i * i
+
+
+mygenerator = createGenerator()  # create a generator
+print(mygenerator)  # mygenerator is an generator object
+for i in mygenerator:
+    print(i)
+
+# >> [0, 2, 4, 6]
+def multipliers():
+    # return [lambda x: i * x for i in range(4)]
+    # return [lambda x, i=i: i * x for i in range(4)]
+    for i in range(4):
+        yield lambda x: i * x
+
+
+print([m(2) for m in multipliers()])
+
+
+def func(values):
+    for value in values:
+        print(f"func:{value}")
+        yield value
+
+
+import sys
+
+
+def fibonacci(n):
+    a, b, counter = 0, 1, 0
+    while True:
+        if (counter > n):
+            return
+        yield
+        a, b = b, a + b
+        counter += 1
+
+
+f = fibonacci(10)
+while True:
+    try:
+        print(next(f), end=" ")
+    except StopIteration:
+        sys.exit()
+
+# def triangle():
+#     _list, new_list = [], []
+#     while True:
+#         length = len(_list)
+#         if length == 0:
+#             new_list.append(1)
+#         else:
+#             for times in range(length + 1):
+#                 if times == 0:
+#                     new_list.append(1)
+#                 elif times == length:
+#                     new_list.append(1)
+#                 else:
+#                     times = _list[times - 1] + _list[times]
+#                     new_list.append(times)
+#         yield new_list
+#         _list = new_list.copy()
+#         new_list.clear()
Index: PythonCode/Basis/类/面向对象/面向对象.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Basis/类/面向对象/面向对象.py	(date 1593506622251)
+++ PythonCode/Basis/类/面向对象/面向对象.py	(date 1593506622251)
@@ -0,0 +1,10 @@
+class Solution:
+    def sumNums(self, n:int) -> int:
+        return n and (n + self.sumNums(n - 1))
+        # n > 1 and self.sumNums(n - 1)
+        # self.result += n
+        # return self.result
+        #
+print(Solution().sumNums(10))
+
+print(sum(range(1, 10)))
\ No newline at end of file
Index: PythonCode/Basis/类/继承/习题集.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Basis/类/继承/习题集.py	(date 1591870197642)
+++ PythonCode/Basis/类/继承/习题集.py	(date 1591870197642)
@@ -0,0 +1,21 @@
+
+
+class Parent(object):
+    x = 1
+
+
+class Child1(Parent):
+    pass
+
+
+class Child2(Parent):
+    pass
+
+
+print(Parent.x, Child1.x, Child2.x)
+
+Child1.x = 2
+print(Parent.x, Child1.x, Child2.x)
+
+Parent.x = 3
+print(Parent.x, Child1.x, Child2.x)
Index: PythonCode/Basis/AbnormalMoudle/Moudle/Moudle.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Basis/AbnormalMoudle/Moudle/Moudle.py	(date 1591886336666)
+++ PythonCode/Basis/AbnormalMoudle/Moudle/Moudle.py	(date 1591886336666)
@@ -0,0 +1,16 @@
+
+# sys模块
+import sys
+print(f"{sys.stdout.write}")
+
+# 今天是今年第几天
+import datetime
+
+
+def dayofyear():
+    year = int(input())
+    month = int(input())
+    day = int(input())
+    date1 = datetime.date(year=year, month=month, day=day)
+    date2 = datetime.date(year=year, month=1, day=1)
+    return (date1 - date2).days + 1
Index: PythonCode/MultitaskProgramming/TheThread/ThreadsCommunication/线程间的通信.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/MultitaskProgramming/TheThread/ThreadsCommunication/线程间的通信.py	(date 1591890318311)
+++ PythonCode/MultitaskProgramming/TheThread/ThreadsCommunication/线程间的通信.py	(date 1591890318311)
@@ -0,0 +1,351 @@
+# 线程通信=====(队列) ---- from queue import Queue
+# 进程池中进程通信=====(队列) --- from multiprocess.Manager import Queue
+# 多进程通信=========(队列)   ---- from multiprocess import Queue
+
+# ! /usr/bin/evn python3
+# --*-- coding: utf-8 --*--
+
+# 1. python多线程
+
+# 该实例反编译来说明函数执行流程
+import dis
+
+
+def add(a):
+    a = a + 1
+    return a
+
+
+print(dis.dis(add))
+
+# Python中一个线程对应于C语言中的一个线程（CPython而言）（Python并不一定就慢，视情况而定）
+# pypy解释器专门克服gil慢的一种解释器（去gil化）
+# GIL使用同一个时刻只有一个线程在一个cpu上执行字节码，无法将多个线程映射到多个CPU上
+# gil锁会根据执行的字节码或时间片划分适当的释放（python内部实现机制）
+# 该实例来说明GIL在某种情况下会自动释放让下一个线程去执行（时间片来回切换）
+
+# 反编译（函数执行流程）同一时刻只有一个线程在CPU上执行
+total = 0
+
+
+def add():
+    global total
+    for i in range(1000000):
+        total += 1
+
+
+def desc():
+    global total
+    for j in range(1000000):
+        total -= 1
+
+
+import threading
+
+threading1 = threading.Thread(target=add)
+threading2 = threading.Thread(target=desc)
+
+threading1.start()
+threading2.start()
+
+threading1.join()
+threading2.join()
+print(total)
+
+# 对于io操作来说，多线程和多进程差别不大（用两种方法实现Python多线程编写）
+# 1、通过Thread类实例化(适用简单的或是线程池)
+
+# 以模拟简单的爬取文章列表页在获取详情页作一示例
+import time
+import threading
+
+
+def get_detail_html(url):
+    # 爬取文章详情页
+    print("get detail html started")
+    time.sleep(2)
+    print("get detail html end")
+
+
+def get_detail_url(url):
+    # 爬取文章列表页
+    print("get url started")
+    time.sleep(4)
+    print("get detail url end")
+
+
+if __name__ == "__main__":
+    thread1 = threading.Thread(target=get_detail_html, args=("",))  # 线程1
+    thread2 = threading.Thread(target=get_detail_url, args=("",))  # 线程2
+    # thread1.setDaemon(True) #守护线程
+    # thread2.setDaemon(True) #守护线程
+    start_time = time.time()
+    thread1.start()
+    thread2.start()
+    # thread1.join() #阻塞等待
+    # thread2.join() #阻塞等待
+    print("last time: {}".format(time.time() - start_time))  # 主线程
+
+# 2、通过集成Thread来实现多线程
+import threading
+import time
+
+
+class GetDetailHtml(threading.Thread):
+    def __init__(self, name):  # 重写__init__方法
+        super().__init__(name=name)  # 调用__init__方法
+
+    def run(self):  # 重写run方法,而非start方法
+        print("get detail html")
+        time.sleep(2)
+        print("get html end")
+
+
+class GetDetailUrl(threading.Thread):
+    def __init__(self, name):  # 重写__init__方法
+        super().__init__(name=name)  # 调用__init__方法
+
+    def run(self):  # 重写run方法，而非start方法(在此可以编写逻辑复杂的程序)
+        print("get detail url")
+        time.sleep(4)
+        print("get url end")
+
+
+if __name__ == "__main__":
+    thread1 = GetDetailHtml("get_detail_html")
+    thread2 = GetDetailUrl("get_detail_url")
+    start_time = time.time()
+    thread1.start()
+    thread2.start()
+    thread1.join()  # 阻塞等待回收
+    thread2.join()  ##阻塞等待回收
+    # 当主线程退出的时候，子线程kill掉
+    print("last time: {}".format(time.time() - start_time))
+
+# 2、线程间的通信方式–共享变量
+# !/usr/bin/evn python3
+# --*-- coding: utf-8 --*--
+
+# 线程之间的通信
+
+# 1、线程间的通信方式--共享变量（不推荐）
+# 如果是各种数据的时候，也可首选使用共享变量而非queue
+# 共享变量的操作并不是线程安全的操作，为了达到预期的效果必须在这些操作上加上一把锁，能够安照预期的效果在线程之间按照顺序进行同步
+# 多进程中共享变量是行不通的
+# 声明一个全局变量，将这个全局变量在各个线程中使用
+
+
+# 以模拟简单的爬取文章列表页在获取详情页作一示例
+import time
+import threading
+
+# 设置全局变量的方式
+detail_url_list = []  # 作用：获取文章的列表页并获取文章详情页的url
+
+
+# (该列表（或全局或全局变量）可以定义在.py文件中，直接from  模块 import  xx （xx.py）--> xx.全局变量）
+# from chaper11 import variables  不推荐：from chapter11.variables import detail_url_list
+# detail_url_list = variables.detail_url_list
+
+# 这种方式是通过声明全局变量global的方式进行通信，非常原始并且不够灵活
+def get_detail_html():
+    # 爬取文章详情页
+    global detail_url_list
+    while True:
+        if len(detail_url_list):
+            url = detail_url_list.pop()
+            # for url in detail_url_list:
+            print("get detail html started")
+            time.sleep(2)
+            print("get detail html end")
+
+
+def get_detail_url():
+    global detail_url_list
+    while True:
+        # 爬取文章列表页
+        print("get url started")
+        time.sleep(2)
+        for i in range(20):
+            detail_url_list.append("http://projectstedu.com/{id}".format(id=i))
+        print("get detail url end")
+
+
+if __name__ == "__main__":
+    thread_detail_url = threading.Thread(target=get_detail_url)  # 线程1
+    thread_detail_url.start()
+    for i in range(10):
+        html_thread = threading.Thread(target=get_detail_html)
+        html_thread.start()
+    start_time = time.time()
+    # 当主线程退出的时候，子线程kill掉
+    print("last time: {}".format(time.time() - start_time))
+
+# 根据上面进行变形后的程序
+
+# 以模拟简单的爬取文章列表页在获取详情页作一示例
+import time
+import threading
+
+# 设置引用的方式
+detail_url_list = []  # 作用：获取文章的列表页并获取文章详情页的url
+
+
+# (该列表（或全局或全局变量）可以定义在.py文件中，直接from  模块 import  xx （xx.py）--> xx.全局变量）
+# from chaper11 import variables  不推荐：from chapter11.variables import detail_url_list
+# detail_url_list = variables.detail_url_list
+
+# 这种方式是通过引用变量参数的方式进行通信，足够灵活
+def get_detail_html(detail_url_list):  # 传入引用，较灵活的方法
+    # 爬取文章详情页
+    while True:
+        # global detail_url_list(去掉全局变量）
+        if len(detail_url_list):
+            url = detail_url_list.pop()
+            # for url in detail_url_list:
+            print("get detail html started")
+            time.sleep(2)
+            print("get detail html end")
+
+
+def get_detail_url(detail_url_list):  # 传入引用，较灵活的方法
+    # global detail_url_list  (去掉全局变量）
+    # 爬取文章列表页
+    while True:
+        print("get url started")
+        time.sleep(4)
+        for i in range(20):
+            detail_url_list.append("http://projectstedu.com/{id}".format(id=i))
+        print("get detail url end")
+
+
+if __name__ == "__main__":
+    thread_detail_url = threading.Thread(target=get_detail_url, args=(detail_url_list,))  # 线程1
+    thread_detail_url.start()
+    for i in range(10):
+        html_thread = threading.Thread(target=get_detail_html, args=(detail_url_list,))
+        html_thread.start()
+    start_time = time.time()
+    # 当主线程退出的时候，子线程kill掉
+    print("last time: {}".format(time.time() - start_time))
+
+# 3、线程间的通信方式–通过Queue模块进行线程间同步
+# !/usr/bin/evn python3
+# --*-- coding: utf-8 --*--
+
+# 1、线程间的通信方式--通过queue的方式进行线程间同步（推荐）
+# 线程间需要通信，使用全局变量需要加锁。
+# 使用queue模块，可在线程间进行通信，并保证了线程安全。
+
+
+# 以模拟简单的爬取文章列表页在获取详情页作一示例
+# queue是线程安全，不加锁，效率高，因为queue用了python中的deque() 双端队列，而deque（）则是线程安全的，在字节码的级别上就已经达到了线程安全
+from queue import Queue
+import time
+import threading
+
+# 设置引用的方式
+detail_url_list = []  # 作用：获取文章的列表页并获取文章详情页的url
+
+
+# (该列表（或全局或全局变量）可以定义在.py文件中，直接from  模块 import  xx （xx.py）--> xx.全局变量）
+# from chaper11 import variables  不推荐：from chapter11.variables import detail_url_list
+# detail_url_list = variables.detail_url_list
+
+# 这种方式是通过引用变量参数的方式进行通信，足够灵活
+def get_detail_html(queue):  # 传入引用，较灵活的方法
+    # 爬取文章详情页
+    while True:
+        url = queue.get()
+        # for url in detail_url_list:
+        print("get detail html started")
+        time.sleep(2)
+        print("get detail html end")
+
+
+def get_detail_url(queue):  # 传入引用，较灵活的方法
+    # global detail_url_list  (去掉全局变量）
+    # 爬取文章列表页
+    while True:
+        print("get url started")
+        time.sleep(4)
+        for i in range(20):
+            queue.put("http://projectstedu.com/{id}".format(id=i))  # 阻塞等待有空闲空间为止（put，参数block默认为True，阻塞状态,可以设置timeout）
+        print("get detail url end")
+
+
+if __name__ == "__main__":
+    detail_url_queue = Queue(maxsize=1000)
+    thread_detail_url = threading.Thread(target=get_detail_url, args=(detail_url_list,))  # 线程1
+    thread_detail_url.start()
+    for i in range(10):
+        html_thread = threading.Thread(target=get_detail_html, args=(detail_url_list,))
+        html_thread.start()
+
+    # detail_url_queue.task_done()  调用task_done()函数join()函数才会退出，停止退出的作用
+    # detail_url_queue.join()  阻塞等待
+
+    start_time = time.time()
+    # 当主线程退出的时候，子线程kill掉
+    print("last time: {}".format(time.time() - start_time))
+
+
+# python 多线程中子线程和主线程相互通信
+# !/usr/bin/python
+# coding:utf8
+'''
+多线程和queue配合使用，实现子线程和主线程相互通信的例子
+'''
+import threading
+
+__author__ = "Kenny.Li"
+
+from queue import Queue
+import time
+import random
+
+q = Queue()
+
+
+class MyThread(threading.Thread):
+    def __init__(self, q, t, j):
+        super(MyThread, self).__init__()
+        self.q = q
+        self.t = t
+        self.j = j
+
+    def run(self):
+        time.sleep(self.j)
+        self.q.put(u"我是第%d个线程，我睡眠了%d秒,当前时间是%s" % (self.t, self.j, time.ctime()))
+
+
+count = 0
+threads = []
+for i in range(15):
+    j = random.randint(1, 8)
+    threads.append(MyThread(q, i, j))
+for mt in threads:
+    mt.start()
+print("start time: ", time.ctime())
+while True:
+    if not q.empty():
+        print(f"{q.get()}")
+        count += 1
+    if count == 15:
+        break
+
+"""
+下面对以上代码进行解释：
+
+1，q 是实例化了的队列对象，具有FIFO性。首先定义一个自己的线程类，重写run方法。注意在构造方法中传入q队列，用于接收每个线程需要返回的消息
+
+2，第26行，通过q.put()方法，将每个子线程要返回给主线程的消息，存到队列中。
+
+3，从第31行开始，生成15个子线程，加入到线程组里，每个线程随机睡眠1-8秒（模拟每个线程干活时间的长短不同）
+
+4，第34-35行，循环开启所有子线程
+
+5，第36行，打印开始时间
+
+6，通过一个while循环，当q队列中不为空时，通过q.get()方法，循环读取队列q中的消息，每次计数器加一，当计数器到15时，证明所有子线程的消息都已经拿到了，此时循环停止。
+"""
\ No newline at end of file
Index: PythonCode/MultitaskProgramming/TheProcess/InterprocessCommunication/进程间的通信.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/MultitaskProgramming/TheProcess/InterprocessCommunication/进程间的通信.py	(date 1591889479785)
+++ PythonCode/MultitaskProgramming/TheProcess/InterprocessCommunication/进程间的通信.py	(date 1591889479785)
@@ -0,0 +1,143 @@
+# -*- coding:utf-8 -*-
+
+import os
+import random
+import time
+import threading
+from multiprocessing import Process, Pool, Pipe, Manager, Queue
+
+# 线程通信=====(队列) ---- from queue import Queue
+# 进程池中进程通信=====(队列) --- from multiprocess.Manager import Queue
+# 多进程通信=========(队列)   ---- from multiprocess import Queue
+
+
+# 进程间的通信Demo:
+# 写数据进程执行的代码：
+
+
+def write(queue):
+    for value in ["A", "B", "C"]:
+        print(f"Put {value} to queue...")
+        queue.put(value)
+        time.sleep(random.random())
+
+
+# 读数据进程执行的代码:
+def read(queue):
+    while True:
+        if not queue.empty():
+            value = queue.get(True)
+            print(f"Get {value} from queue.")
+            time.sleep(random.random())
+        else:
+            break
+
+
+if __name__ == "__main__":
+    # 父进程创建 Queue，并传给各个子进程：
+    queue = Queue()
+    pw = Process(target=write, args=(queue,))
+    pr = Process(target=read, args=(queue,))
+    # 启动子进程 pw，写入:
+    pw.start()
+    # 等待 pw 结束:
+    pw.join()
+    # 启动子进程 pr，读取:
+    pr.start()
+    # 等待 pr 结束:
+    pr.join()
+    # pr 进程里是死循环，无法等待其结束，只能强行终止:
+    print(">>\n所有数据都已写入并读完")
+
+
+class Producer(Process):
+    def __init__(self, queue):
+        super(Producer, self).__init__()
+        self.queue = queue
+
+    def run(self):
+        # 将需要通信的数据写入队列中;
+        for i in range(10):
+            self.queue.put(i)
+            time.sleep(0.1)
+            print("传递消息内容为%s" % i)
+
+
+class Consumer(Process):
+    def __init__(self, queue):
+        super(Consumer, self).__init__()
+        self.queue = queue
+
+    def run(self):
+        while True:
+            time.sleep(0.1)
+            recvData = self.queue.get()
+            print("接受到另一进程传递的数据: %s" % recvData)
+            break
+
+
+if __name__ == '__main__':
+    queue = Queue()
+    p1 = Producer(queue)
+    c1 = Consumer(queue)
+    p1.start()
+    c1.start()
+    p1.join()
+    c1.join()
+
+
+# 进程池间的通信
+
+
+def producer(queue):
+    print(f"producer进程号：{os.getpid()}")
+    queue.put("a")
+    time.sleep(2)
+
+
+def consumer(queue):
+    print(f"consumer进程号：{os.getpid()}")
+    time.sleep(2)
+    data = queue.get()
+    print(data)
+
+
+if __name__ == "__main__":
+    # pool中的进程间通信需要使用Manager
+    queue = Manager().Queue()
+    pool = Pool(3)  # 定义一个进程池，最大进程数3
+    # Pool().apply_async(要调用的目标,(传递给目标的参数元祖,))
+    # 每次循环将会用空闲出来的子进程去调用目标
+    pool.apply_async(producer, args=(queue,))
+    pool.apply_async(consumer, args=(queue,))
+    pool.close()  # 关闭进程池，关闭后pool不再接收新的请求
+    pool.join()  # 等待pool中所有子进程执行完成，必须放在close语句之后
+
+
+# Pipe(管道)
+# 1). Pipe管道，进程间通信的方式, l类似于 ls | wc -l;
+# 2). Pipe()返回两个连接对象, 分别代表管道的两边;
+# 3). 管道通信操作的方法: send(), recv;
+# 4). 管道间的通信是双向的， 既可以发送，也可以接收；
+
+def producer(pipe):
+    pipe.send("a")
+    time.sleep(2)
+    print(pipe.recv())
+
+
+def consumer(pipe):
+    time.sleep(2)
+    data = pipe.recv()
+    pipe.send("b")
+    print(data)
+
+
+if __name__ == "__main__":
+    # Pipe实现两进程间通信
+    s_pipe, r_pipe = Pipe()
+    pool = Pool()
+    pool.apply_async(producer, args=(s_pipe,))
+    pool.apply_async(consumer, args=(r_pipe,))
+    pool.close()
+    pool.join()
\ No newline at end of file
Index: PythonCode/Re/python_Re.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Re/python_Re.py	(date 1591847307739)
+++ PythonCode/Re/python_Re.py	(date 1591847307739)
@@ -0,0 +1,99 @@
+# -*_ coding:utf-8 -*-
+import re
+
+# 1. 将以下网址提取出域名：
+# 提取出域名
+s1 = """http://www.interoem.com/messageinfo.asp?id=35`
+http://3995503.com/class/class09/news_show.asp?id=14
+http://lib.wzmc.edu.cn/news/onews.asp?id=769
+https://www.zy-ls.com/alfx.asp?newsid=377&id=6
+http://www.fincm.com/newslist.asp?id=415"""
+
+p = r"(http.?://.+?/).+"
+print(re.sub(p, lambda x: x.group(1), s1))
+
+# 2. 去除以下html文件中的标签，只显示文本信息。
+# 去除标签
+s2 = "<div>\
+<p>岗位职责：</p>\
+<p>完成推荐算法、数据统计、接口、后台等服务器端相关工作</p>\
+<p><br></p>\
+<p>必备要求：</p>\
+<p>良好的自我驱动力和职业素养，工作积极主动、结果导向</p>\
+<p>&nbsp;<br></p>\
+<p>技术要求：</p>\
+<p>1、一年以上 Python 开发经验，掌握面向对象分析和设计，了解设计模式</p>\
+<p>2、掌握HTTP协议，熟悉MVC、MVVM等概念以及相关WEB开发框架</p>\
+<p>3、掌握关系数据库开发设计，掌握 SQL，熟练使用 MySQL/PostgreSQL 中的一种<br></p>\
+<p>4、掌握NoSQL、MQ，熟练使用对应技术解决方案</p>\
+<p>5、熟悉 Javascript/CSS/HTML5，JQuery、React、Vue.js</p>\
+<p>&nbsp;<br></p>\
+<p>加分项：</p>\
+<p>大数据，数理统计，机器学习，sklearn，高性能，大并发。</p>\
+</div>"
+t = "(</?\w+>|&nbsp;)"
+p = r"(<[^>]*>|&nbsp;)"
+print(re.sub(p, " ", s2))
+# print(re.sub(r"(<[^>]*>|&nbsp;)", " ", s2))
+# 3. 提取出如下字符串中的单词：hello world ha ha
+# 提取出单词
+s3 = "hello world ha ha"
+print(re.split(r" +", s3))  # 用split方法分割空格
+print(re.findall(r"\b\w+\b", s3))
+
+# 4. IP
+if re.match(r"^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$",
+            "192.168.103.1"):
+    print("IP vaild")
+else:
+    print("IP invaild")
+
+# 精确提取IP
+string_ip = "is this 289.22.22.22 ip ?"
+result = re.findall(r"\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b", string_ip)
+if result:
+    print(result)
+else:
+    print("re cannot find ip")
+
+# 5. \\
+s = "c:\\a\\b\\d"
+print(re.match("c:\\\\a", s).group())
+print(re.match(r"c:\\a", s).group())
+
+# 6. match、search、findall、finditer
+data = 'bat bit btt a ta tib atb but hat hit hut'
+print(re.findall(r"\b[bh][aiu]t\b", data))
+
+s4 = "23432WerWre2342WerWreW "
+p = r"(\d*)([a-zA-Z]*)"
+
+# match(从首字母开始开始匹配，string如果包含pattern子串，则匹配成功，返回Match对象，失败则返回None，若要完全匹配，pattern要以$结尾。)
+m = re.match(p, s4)
+print(f"{m.group()}\n{m.group(0)}\n{m.group(1)}\n{m.group(2)}\n{m.groups()}")
+
+# findall(返回string中所有与pattern相匹配的全部字串，返回形式为数组。)
+print(re.findall(p, s4))
+
+s5 = "11113446777"
+print(re.findall(r"(\d)\1*", s5))
+
+# search
+m = re.search(r"(\d)\*", s5)  # print(m.group())报错：AttributeError: 'NoneType' object has no attribute 'group'
+n = re.search(r"(\d)\1*", s5)
+print(f"{n.group()}\n{n.group(0)}\n{n.group(1)}\n{n.groups()}")
+
+# finditer
+o = re.finditer(r"(\d)\1*", s5)
+print(f"{o.__next__().group()}\n{o.__next__().group()}\n{o.__next__().group()}\n{o.__next__().group()}\n{o.__next__().group()}")
+
+# p = r"(\d)\1+([a-zA-Z]+)"
+s6 = '1111werwrw3333rertert4444'
+p = r'(\d)\1+([a-zA-Z]*)'
+print(re.findall(p, s6))
+print(re.search(p, s6).group())
+print(re.search(p, s6).group(1))
+print(re.search(p, s6).group(2))
+print(re.search(p, s6).groups())
+o = re.finditer(p, s6)
+print(f"{o.__next__().group()}\n{o.__next__().group()}\n{o.__next__().group()}")
Index: .idea/inspectionProfiles/Project_Default.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/inspectionProfiles/Project_Default.xml	(date 1602759484590)
+++ .idea/inspectionProfiles/Project_Default.xml	(date 1602759484590)
@@ -0,0 +1,20 @@
+<component name="InspectionProjectProfileManager">
+  <profile version="1.0">
+    <option name="myName" value="Project Default" />
+    <inspection_tool class="PyPep8NamingInspection" enabled="true" level="WEAK WARNING" enabled_by_default="true">
+      <option name="ignoredErrors">
+        <list>
+          <option value="N806" />
+          <option value="N802" />
+        </list>
+      </option>
+    </inspection_tool>
+    <inspection_tool class="PyUnresolvedReferencesInspection" enabled="true" level="WARNING" enabled_by_default="true">
+      <option name="ignoredIdentifiers">
+        <list>
+          <option value="list.pop" />
+        </list>
+      </option>
+    </inspection_tool>
+  </profile>
+</component>
\ No newline at end of file
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/vcs.xml	(date 1602759484648)
+++ .idea/vcs.xml	(date 1602759484648)
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/PythonCode/Game" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/Code.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/Code.iml	(date 1602760651453)
+++ .idea/Code.iml	(date 1602760651453)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="PYTHON_MODULE" version="4">
+  <component name="NewModuleRootManager">
+    <content url="file://$MODULE_DIR$" />
+    <orderEntry type="jdk" jdkName="Python 3.7 (code)" jdkType="Python SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/modules.xml	(date 1602759484695)
+++ .idea/modules.xml	(date 1602759484695)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/Code.iml" filepath="$PROJECT_DIR$/.idea/Code.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(date 1602760651555)
+++ .idea/misc.xml	(date 1602760651555)
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="JavaScriptSettings">
+    <option name="languageLevel" value="ES6" />
+  </component>
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.7 (code)" project-jdk-type="Python SDK" />
+</project>
\ No newline at end of file
Index: .idea/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/.gitignore	(date 1602759484935)
+++ .idea/.gitignore	(date 1602759484935)
@@ -0,0 +1,8 @@
+# Default ignored files
+/shelf/
+/workspace.xml
+# Datasource local storage ignored files
+/dataSources/
+/dataSources.local.xml
+# Editor-based HTTP Client requests
+/httpRequests/
Index: .idea/inspectionProfiles/profiles_settings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/inspectionProfiles/profiles_settings.xml	(date 1602759484710)
+++ .idea/inspectionProfiles/profiles_settings.xml	(date 1602759484710)
@@ -0,0 +1,6 @@
+<component name="InspectionProjectProfileManager">
+  <settings>
+    <option name="USE_PROJECT_PROFILE" value="false" />
+    <version value="1.0" />
+  </settings>
+</component>
\ No newline at end of file
Index: PythonCode/Game/俄罗斯方块.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Game/俄罗斯方块.py	(date 1602760793370)
+++ PythonCode/Game/俄罗斯方块.py	(date 1602760793370)
@@ -0,0 +1,446 @@
+# _*_ coding:utf-8 _*_
+'''
+Created on 2017年7月30日上午11:16:44
+
+@author: xiaolin
+
+relief=RAISED
+sticky=N+E+S+W
+'''
+from Tkinter import *
+import random
+import time
+from tkMessageBox import *
+
+# 俄罗斯方块界面的高度
+HEIGHT = 20
+
+# 俄罗斯方块界面的宽度
+WIDTH = 10
+
+ACTIVE = 1
+PASSIVE = 0
+TRUE = 1
+FALSE = 0
+
+style = [
+    [[(0, 0), (0, 1), (1, 1), (2, 1)], [(1, 0), (1, 1), (1, 2), (0, 2)], [(0, 1), (1, 1), (2, 1), (2, 2)],
+     [(1, 0), (2, 0), (1, 1), (1, 2)]],  # j
+    [[(1, 0), (1, 1), (1, 2), (2, 1)], [(1, 0), (0, 1), (1, 1), (2, 1)], [(1, 0), (1, 1), (1, 2), (0, 1)],
+     [(0, 1), (1, 1), (2, 1), (1, 2)]],  # T
+    [[(0, 1), (1, 1), (2, 1), (2, 0)], [(0, 0), (1, 0), (1, 1), (1, 2)], [(0, 1), (1, 1), (2, 1), (0, 2)],
+     [(1, 0), (1, 1), (1, 2), (2, 2)]],  # 反L
+    [[(0, 0), (0, 1), (1, 1), (1, 2)], [(2, 1), (1, 1), (1, 2), (0, 2)], [(0, 0), (0, 1), (1, 1), (1, 2)],
+     [(2, 1), (1, 1), (1, 2), (0, 2)]],  # Z
+    [[(1, 0), (1, 1), (0, 1), (0, 2)], [(0, 1), (1, 1), (1, 2), (2, 2)], [(1, 0), (1, 1), (0, 1), (0, 2)],
+     [(0, 1), (1, 1), (1, 2), (2, 2)]],  # 反Z
+    [[(0, 0), (0, 1), (1, 1), (1, 0)], [(0, 0), (0, 1), (1, 1), (1, 0)], [(0, 0), (0, 1), (1, 1), (1, 0)],
+     [(0, 0), (0, 1), (1, 1), (1, 0)]],  # 田
+    [[(1, 0), (1, 1), (1, 2), (1, 3)], [(0, 1), (1, 1), (2, 1), (3, 1)], [(1, 0), (1, 1), (1, 2), (1, 3)],
+     [(0, 1), (1, 1), (2, 1), (3, 1)]]  # 长条
+]
+
+root = Tk();
+root.title('俄罗斯方块')
+
+
+class App(Frame):
+    def __init__(self, master):
+        Frame.__init__(self)
+        master.bind('<Up>', self.Up)
+        master.bind('<Left>', self.Left)
+        master.bind('<Right>', self.Right)
+        master.bind('<Down>', self.Down)
+
+        master.bind('<space>', self.Space)
+        master.bind('<Control-Shift-Key-F12>', self.Play)
+        master.bind('<Key-P>', self.Pause)
+        master.bind('<Key-S>', self.StartByS)
+
+        # rgb颜色值
+        self.backg = "#%02x%02x%02x" % (120, 150, 30)  # 大背景
+        self.frontg = "#%02x%02x%02x" % (40, 120, 150)  # 下一个形状颜色
+        self.nextg = "#%02x%02x%02x" % (150, 100, 100)  # 小背景
+        self.flashg = "#%02x%02x%02x" % (210, 130, 100)  # 炸的颜色
+
+        self.LineDisplay = Label(master, text='Lines: ', bg='black', fg='red')
+        self.Line = Label(master, text='0', bg='black', fg='red')
+        self.ScoreDisplay = Label(master, text='Score: ', bg='black', fg='red')
+        self.Score = Label(master, text='0', bg='black', fg='red')
+        self.SpendTimeDisplay = Label(master, text='Time: ', bg='black', fg='red')
+        self.SpendTime = Label(master, text='0.0', bg='black', fg='red')
+
+        self.LineDisplay.grid(row=HEIGHT - 2, column=WIDTH, columnspan=2)
+        self.Line.grid(row=HEIGHT - 2, column=WIDTH + 2, columnspan=3)
+        self.ScoreDisplay.grid(row=HEIGHT - 1, column=WIDTH, columnspan=2)
+        self.Score.grid(row=HEIGHT - 1, column=WIDTH + 2, columnspan=3)
+        self.SpendTimeDisplay.grid(row=HEIGHT - 4, column=WIDTH, columnspan=2)
+        self.SpendTime.grid(row=HEIGHT - 4, column=WIDTH + 2, columnspan=3)
+
+        self.TotalTime = 0.0
+        self.TotalLine = 0
+        self.TotalScore = 0
+
+        # 游戏结束
+        self.isgameover = FALSE
+        # 暂停
+        self.isPause = FALSE
+        # 开始
+        self.isStart = FALSE
+        self.NextList = []  # 整个小背景
+        self.NextRowList = []  # 一行小背景
+
+        self.px = 0
+        self.py = 0  # 记录方块参考点
+
+        # 渲染小背景
+        r = 0;
+        c = 0
+        for k in range(4 * 4):
+            LN = Label(master, text='    ', bg=str(self.nextg), fg='white', relief=FLAT, bd=3)
+            LN.grid(row=r, column=WIDTH + c, sticky=N + E + S + W)
+            self.NextRowList.append(LN)
+            c = c + 1
+            if c >= 4:
+                r = r + 1;
+                c = 0
+                self.NextList.append(self.NextRowList)
+                self.NextRowList = []
+
+        # 渲染大背景
+        self.BlockList = []
+        self.BlockRowList = []
+        self.LabelList = []
+        self.LabelRowList = []
+        row = 0;
+        col = 0
+        for i in range(HEIGHT * WIDTH):
+            L = Label(master, text='    ', bg=str(self.backg), fg='white', relief=FLAT, bd=4)
+            L.grid(row=row, column=col, sticky=N + E + S + W)
+            L.row = row;
+            L.col = col;
+            L.isactive = PASSIVE
+            self.BlockRowList.append(0);  # 大背景每个格子初始化为0值
+            self.LabelRowList.append(L)
+            col = col + 1
+            if col >= WIDTH:
+                row = row + 1;
+                col = 0
+                self.BlockList.append(self.BlockRowList)
+                self.LabelList.append(self.LabelRowList)
+                self.BlockRowList = []
+                self.LabelRowList = []
+
+        # file
+        fw = open('text.txt', 'a')
+        fw.close()
+        hasHead = FALSE
+        f = open('text.txt', 'r')
+        if f.read(5) == 'score':
+            hasHead = TRUE
+        f.close()
+        self.file = open('text.txt', 'a')
+        if hasHead == FALSE:
+            self.file.write('score    line    time    scorePtime    linePtime    scorePline    date/n')
+            self.file.flush()
+
+        self.time = 1000
+        self.OnTimer()
+
+    def __del__(self):
+        # self.file.close()
+        pass
+
+    def Pause(self, event):
+        self.isPause = 1 - self.isPause
+
+    def Up(self, event):
+        BL = self.BlockList  # 格子的值
+        LL = self.LabelList  # 格子Label
+
+        Moveable = TRUE  # 是否可旋转
+
+        # 代码编写开始
+        nowStyle = style[self.xnow][(self.ynow)]
+        newStyle = style[self.xnow][(self.ynow + 1) % 4]  # 算出下一俄罗斯方块
+        self.ynow = (self.ynow + 1) % 4  # 此行代码非常重要，否则响应UP时，只能变第一次
+
+        print("nowStyle:" + str(nowStyle) + "=====>>newStyle:" + str(newStyle))
+
+        # 根据现有形状中每个label的坐标计算出旋转后目标坐标(x,y)
+        SourceList = [];
+        DestList = []
+
+        for i in range(4):
+            SourceList.append([nowStyle[i][0] + self.px, nowStyle[i][1] + self.py])
+            x = newStyle[i][0] + self.px
+            y = newStyle[i][1] + self.py
+            DestList.append([x, y])
+
+            if x < 0 or x >= HEIGHT or y < 0 or y >= WIDTH:  # or BL[x][y]==1 or LL[x][y].isactive==PASSIVE
+                Moveable = FALSE
+
+        if Moveable == TRUE:
+            for i in range(len(SourceList)):
+                self.Empty(SourceList[i][0], SourceList[i][1])
+            for i in range(len(DestList)):
+                self.Fill(DestList[i][0], DestList[i][1])
+
+    def Left(self, event):
+        BL = self.BlockList;
+        LL = self.LabelList
+        Moveable = TRUE
+        for i in range(HEIGHT):
+            for j in range(WIDTH):
+                if LL[i][j].isactive == ACTIVE and j - 1 < 0: Moveable = FALSE
+                if LL[i][j].isactive == ACTIVE and j - 1 >= 0 and BL[i][j - 1] == 1 and LL[i][
+                    j - 1].isactive == PASSIVE: Moveable = FALSE
+        if Moveable == TRUE:
+            self.py -= 1
+            for i in range(HEIGHT):
+                for j in range(WIDTH):
+                    if j - 1 >= 0 and LL[i][j].isactive == ACTIVE and BL[i][j - 1] == 0:
+                        self.Fill(i, j - 1);
+                        self.Empty(i, j)
+
+    def Right(self, event):
+        BL = self.BlockList;
+        LL = self.LabelList
+        Moveable = TRUE
+        for i in range(HEIGHT):
+            for j in range(WIDTH):
+                if LL[i][j].isactive == ACTIVE and j + 1 >= WIDTH: Moveable = FALSE
+                if LL[i][j].isactive == ACTIVE and j + 1 < WIDTH and BL[i][j + 1] == 1 and LL[i][
+                    j + 1].isactive == PASSIVE: Moveable = FALSE
+        if Moveable == TRUE:
+            self.py += 1
+            for i in range(HEIGHT - 1, -1, -1):
+                for j in range(WIDTH - 1, -1, -1):
+                    if j + 1 < WIDTH and LL[i][j].isactive == ACTIVE and BL[i][j + 1] == 0:
+                        self.Fill(i, j + 1);
+                        self.Empty(i, j)
+
+    def Down(self, event):
+        BL = self.BlockList;
+        LL = self.LabelList
+        Moveable = TRUE
+        for i in range(HEIGHT):
+            for j in range(WIDTH):
+                if LL[i][j].isactive == ACTIVE and i + 1 >= HEIGHT: Moveable = FALSE
+                if LL[i][j].isactive == ACTIVE and i + 1 < HEIGHT and BL[i + 1][j] == 1 and LL[i + 1][
+                    j].isactive == PASSIVE: Moveable = FALSE
+        if Moveable == TRUE and self.isStart:
+            self.px += 1
+            for i in range(HEIGHT - 1, -1, -1):
+                for j in range(WIDTH - 1, -1, -1):
+                    if i + 1 < HEIGHT and LL[i][j].isactive == ACTIVE and BL[i + 1][j] == 0:
+                        self.Fill(i + 1, j);
+                        self.Empty(i, j);
+        if Moveable == FALSE:
+            for i in range(HEIGHT):
+                for j in range(WIDTH):
+                    LL[i][j].isactive = PASSIVE
+            self.JudgeLineFill()
+            self.Start()
+            if self.isgameover == TRUE: showinfo('T_T', 'The game is over!');self.Distroy();return FALSE
+            for i in range(4):
+                for j in range(4):
+                    self.NextEmpty(i, j)
+            self.Rnd()
+        return Moveable
+
+    def Space(self, event):
+        while 1:
+            if self.Down(0) == FALSE: break
+
+    def OnTimer(self):
+        if self.isStart == TRUE and self.isPause == FALSE:
+            self.TotalTime = self.TotalTime + float(self.time) / 1000
+            self.SpendTime.config(text=str(self.TotalTime))
+
+        if self.isPause == FALSE:
+            self.Down(0)
+        if self.TotalScore >= 1000: self.time = 900
+        if self.TotalScore >= 2000: self.time = 750
+        if self.TotalScore >= 3000: self.time = 600
+        if self.TotalScore >= 4000: self.time = 400
+        self.after(self.time, self.OnTimer)  # 随着分数增大，俄罗斯方块下降速度加快
+
+    def JudgeLineFill(self):
+        BL = self.BlockList;
+        LL = self.LabelList
+        count = 0;
+        LineList = []
+        for i in range(WIDTH): LineList.append(1)
+        # display flash
+        for i in range(HEIGHT):
+            if BL[i] == LineList:
+                count = count + 1
+                for k in range(WIDTH):
+                    LL[i][k].config(bg=str(self.flashg))
+                    LL[i][k].update()
+        if count != 0: self.after(100)
+        # delete block
+        for i in range(HEIGHT):
+            if BL[i] == LineList:
+                # count=count+1
+                for j in range(i, 0, -1):
+                    for k in range(WIDTH):
+                        BL[j][k] = BL[j - 1][k]
+                        LL[j][k]['relief'] = LL[j - 1][k].cget('relief')
+                        LL[j][k]['bg'] = LL[j - 1][k].cget('bg')
+                for l in range(WIDTH):
+                    BL[0][l] = 0
+                    LL[0][l].config(relief=FLAT, bg=str(self.backg))
+        self.TotalLine = self.TotalLine + count
+        if count == 1: self.TotalScore = self.TotalScore + 1 * WIDTH
+        if count == 2: self.TotalScore = self.TotalScore + 3 * WIDTH
+        if count == 3: self.TotalScore = self.TotalScore + 6 * WIDTH
+        if count == 4: self.TotalScore = self.TotalScore + 10 * WIDTH
+        self.Line.config(text=str(self.TotalLine))
+        self.Score.config(text=str(self.TotalScore))
+
+    def Fill(self, i, j):
+        if j < 0: return
+        if self.BlockList[i][j] == 1: self.isgameover = TRUE
+        self.BlockList[i][j] = 1
+        self.LabelList[i][j].isactive = ACTIVE
+        self.LabelList[i][j].config(relief=RAISED, bg=str(self.frontg))
+
+    def Empty(self, i, j):
+        self.BlockList[i][j] = 0
+        self.LabelList[i][j].isactive = PASSIVE
+        self.LabelList[i][j].config(relief=FLAT, bg=str(self.backg))
+
+    def Play(self, event):
+        showinfo('Made in China', '^_^')
+
+    def NextFill(self, i, j):
+        self.NextList[i][j].config(relief=RAISED, bg=str(self.frontg))
+
+    def NextEmpty(self, i, j):
+        self.NextList[i][j].config(relief=FLAT, bg=str(self.nextg))
+
+    def Distroy(self):
+        # save
+        if self.TotalScore != 0:
+            # cehkongfu
+            savestr = '%-9u%-8u%-8.2f%-14.2f%-13.2f%-14.2f%s/n' % (
+                self.TotalScore, self.TotalLine, self.TotalTime
+                , self.TotalScore / self.TotalTime
+                , self.TotalLine / self.TotalTime
+                , float(self.TotalScore) / self.TotalLine
+                , time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()))
+            self.file.seek(0, 2)
+            self.file.write(savestr)
+            self.file.flush()
+
+        for i in range(HEIGHT):
+            for j in range(WIDTH):
+                self.Empty(i, j)
+        self.TotalLine = 0;
+        self.TotalScore = 0;
+        self.TotalTime = 0.0
+        self.Line.config(text=str(self.TotalLine))
+        self.Score.config(text=str(self.TotalScore))
+        self.SpendTime.config(text=str(self.TotalTime))
+        self.isgameover = FALSE
+        self.isStart = FALSE
+        self.time = 1000
+        for i in range(4):
+            for j in range(4):
+                self.NextEmpty(i, j)
+
+    # 游戏开始方块
+    def Start(self):
+        nextStyle = style[self.x][self.y]  # 下一形状
+        self.xnow = self.x
+        self.ynow = self.y  # 记录大背景中的方块
+        self.py = random.randint(0, 6)
+        print("给py赋任意值:" + str(self.py))
+        self.px = 0
+        for ii in range(4):
+            self.Fill(int(nextStyle[ii][0]), int(nextStyle[ii][1]) + self.py)
+        self.isStart = TRUE  # 游戏开始
+
+    # 预处理方块
+    def Rnd(self):
+        self.x = random.randint(0, 6)
+        self.y = random.randint(0, 3)
+        nextStyle = style[self.x][self.y]  # 下一形状
+        for ii in range(4):
+            self.NextFill(int(nextStyle[ii][0]), int(nextStyle[ii][1]))
+
+    # 游戏开始给出一次任意形状的方块
+    def RndFirst(self):
+        self.x = random.randint(0, 6)  # 选择第一个方块style
+        self.y = random.randint(0, 3)
+
+    def Show(self):
+        self.file.seek(0)
+        strHeadLine = self.file.readline()
+        dictLine = {}
+        strTotalLine = ''
+        for OneLine in self.file.readlines():
+            temp = int(OneLine[:5])
+            dictLine[temp] = OneLine
+
+        list = sorted(dictLine.items(), key=lambda d: d[0])
+        ii = 0
+        for onerecord in reversed(list):
+            ii = ii + 1
+            if ii < 11:
+                strTotalLine += onerecord[1]
+        showinfo('Ranking', strHeadLine + strTotalLine)
+
+    def StartByS(self, event):
+        self.RndFirst()
+        self.Start()
+        self.Rnd()
+
+
+def Start():
+    app.RndFirst()
+    app.Start()
+    app.Rnd()
+
+
+def End():
+    app.Distroy()
+
+
+def Set():
+    print("设置功能待完善...")
+
+
+def Show():
+    app.Show()
+
+
+# 主菜单
+mainmenu = Menu(root)
+root['menu'] = mainmenu
+
+# 二级菜单：game
+gamemenu = Menu(mainmenu)
+mainmenu.add_cascade(label='游戏', menu=gamemenu)
+gamemenu.add_command(label='开始', command=Start)
+gamemenu.add_command(label='结束', command=End)
+gamemenu.add_separator()
+gamemenu.add_command(label='退出', command=root.quit)
+
+# 二级菜单：set
+setmenu = Menu(mainmenu)
+mainmenu.add_cascade(label='设置', menu=setmenu)
+setmenu.add_command(label='设置', command=Set)
+
+# 二级菜单：show
+showmenu = Menu(mainmenu)
+mainmenu.add_cascade(label='展示', menu=showmenu)
+showmenu.add_command(label='展示', command=Show)
+
+# 绑定功能
+
+app = App(root)
+# 程序入口
+root.mainloop()
Index: PythonCode/Game/俄罗斯方块实现过程
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Game/俄罗斯方块实现过程	(date 1602761652339)
+++ PythonCode/Game/俄罗斯方块实现过程	(date 1602761652339)
@@ -0,0 +1,650 @@
+
+现在来看一下实现的过程。
+
+外形
+俄罗斯方块整个界面分为两部分，一部分是左边的游戏区域，另一部分是右边的显示区域，显示得分、速度、下一个方块样式等。这里就不放截图了，看上图就可以。
+
+游戏区域跟贪吃蛇一样，是由一个个小方格组成的，为了看得直观，我特意画了网格线。
+
+import sys
+import pygame
+from pygame.locals import *
+
+SIZE = 30  # 每个小方格大小
+BLOCK_HEIGHT = 20  # 游戏区高度
+BLOCK_WIDTH = 10   # 游戏区宽度
+BORDER_WIDTH = 4   # 游戏区边框宽度
+BORDER_COLOR = (40, 40, 200)  # 游戏区边框颜色
+SCREEN_WIDTH = SIZE * (BLOCK_WIDTH + 5)  # 游戏屏幕的宽
+SCREEN_HEIGHT = SIZE * BLOCK_HEIGHT      # 游戏屏幕的高
+BG_COLOR = (40, 40, 60)  # 背景色
+BLACK = (0, 0, 0)
+
+
+def print_text(screen, font, x, y, text, fcolor=(255, 255, 255)):
+    imgText = font.render(text, True, fcolor)
+    screen.blit(imgText, (x, y))
+
+
+def main():
+    pygame.init()
+    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
+    pygame.display.set_caption('俄罗斯方块')
+
+    font1 = pygame.font.SysFont('SimHei', 24)  # 黑体24
+    font_pos_x = BLOCK_WIDTH * SIZE + BORDER_WIDTH + 10  # 右侧信息显示区域字体位置的X坐标
+    font1_height = int(font1.size('得分')[1])
+
+    score = 0           # 得分
+
+    while True:
+        for event in pygame.event.get():
+            if event.type == QUIT:
+                sys.exit()
+
+        # 填充背景色
+        screen.fill(BG_COLOR)
+        # 画游戏区域分隔线
+        pygame.draw.line(screen, BORDER_COLOR,
+                         (SIZE * BLOCK_WIDTH + BORDER_WIDTH // 2, 0),
+                         (SIZE * BLOCK_WIDTH + BORDER_WIDTH // 2, SCREEN_HEIGHT), BORDER_WIDTH)
+        # 画网格线 竖线
+        for x in range(BLOCK_WIDTH):
+            pygame.draw.line(screen, BLACK, (x * SIZE, 0), (x * SIZE, SCREEN_HEIGHT), 1)
+        # 画网格线 横线
+        for y in range(BLOCK_HEIGHT):
+            pygame.draw.line(screen, BLACK, (0, y * SIZE), (BLOCK_WIDTH * SIZE, y * SIZE), 1)
+
+        print_text(screen, font1, font_pos_x, 10, f'得分: ')
+        print_text(screen, font1, font_pos_x, 10 + font1_height + 6, f'{score}')
+        print_text(screen, font1, font_pos_x, 20 + (font1_height + 6) * 2, f'速度: ')
+        print_text(screen, font1, font_pos_x, 20 + (font1_height + 6) * 3, f'{score // 10000}')
+        print_text(screen, font1, font_pos_x, 30 + (font1_height + 6) * 4, f'下一个：')
+
+        pygame.display.flip()
+
+
+if __name__ == '__main__':
+    main()
+方块
+接下来就是要定义方块，方块的形状一共有以下 7 种：
+
+
+I 型
+
+
+O 型
+
+
+T 型
+
+
+S 型
+
+
+Z 型
+
+
+L 型
+
+
+J 型
+这里我做了多次的更改，因为方块最大的长度是长条形的，为4格，所以我统一用了 4 × 4 的方格来定义。这也是可以的，只是后来发现不方便。
+
+为了直观，直接以一个二维数组来定义方块，其中 . 表示空的， 0 表示实心的。（用 . 表示空是为了看得直观，如果用空格会看不清。）
+例如 I 行，以 4 × 4 方格定义为
+
+['.0..',
+ '.0..',
+ '.0..',
+ '.0..']
+和
+
+['....',
+ '....',
+ '0000',
+ '....']
+方块最难的是需要实现旋转功能，比如 I 型，就有横和竖两种形态。所谓旋转，表面上看，是把方块顺时针旋转了 90°，但实际做的时候，我们并不需要正真的去实现这个“旋转”的效果。
+
+最终实现的时候，这些图形都是我们画在界面上的，而每一次刷新，界面上所有内容都会被清空重画，所以旋转只是画当前方块的时候不再画之前的形状，而是画旋转后的形状。
+
+比如这个 I 型，定义成了 4 × 4 的形状，但实际上只需要 1 × 4 或 4 × 1 就可以了，其他剩下的地方都是空的。它不像 T 型，T 型不是一个矩形，如果用一个矩形来定义，必然有 2 个位置是空的。那么，I 型真的有必要定义成 4 × 4 吗？
+
+答案是肯定的。想想看，如果是 4 × 1 的一个横条，旋转后变成 1 × 4 的竖条，这个位置怎么确定？好像有点困难。但是如果是 4 × 4 的正方形，我们只需要固定起点坐标（左上角）不变，把竖条的 4 × 4 直接替换掉横条的 4 × 4 区域，是不是就实现旋转了？而且位置很容易计算。
+
+另外一点，在有些情况下是不可以旋转的。比如 I 型的竖条，在紧贴左右边框的时候是不可以旋转的。这点我有印象，可以肯定。但是对于其他的形状，我就不是很确定了，我百度搜了下，找了个网页版的俄罗斯方块玩了下，发现也是不可以的。例如：
+
+
+
+在紧贴右边框的时候是无法旋转的。如果要每一个形状都去判断一下，那实在是太烦了。从方块的定义入手，就可以很简单的实现。
+
+例如竖条行，定义是：
+
+['.0..',
+ '.0..',
+ '.0..',
+ '.0..']
+竖条是可以贴边的，所以当它在最左边的时候，X 轴坐标是 -1，这是因为定义中左边一竖排是空的。我们只需判定，当方块所定义的形状（包括空的部分）完全在游戏区域内时才可以旋转。
+
+我之前所说，全都定义成 4 × 4 不好，原因就在这里，对于 T 型等其他形状，无法做这个判定。所以，对于 T 型等形状，我们可以定义成 3 × 3 的格式：
+
+['.0.',
+ '000',
+ '...']
+还有一种情况是无法旋转的，就是旋转后的位置已经被别的方块占了。另外下落，左右移动，都要做这个判断。既然这些是一致的，那么就可以用同一个方法来判断。
+
+先要定义一个 game_area 变量，用于存放整个游戏区域当前的状态：
+
+game_area = [['.'] * BLOCK_WIDTH for _ in range(BLOCK_HEIGHT)]
+初始状态全是空的，所以全部用 . 初始化就可以了。
+另外，需要一些变量定义当前下落方块的状态
+
+cur_block = None   # 当前下落方块
+cur_pos_x, cur_pos_y = 0, 0  # 当前下落方块的坐标
+方块我们是以二维数组的方式定义的，并且存在空行和空列，如果我们遍历这个二维数组判断其所在的区域在当前游戏区域内是否已经被别的方块所占，这个是可以实现的。我们考虑另外一种情况，一个竖条形，左边一排是空的，这空的一排是可以移出游戏区域的，这个怎么判断？每次左移的时候都去判断一下左边一排全都是空吗？这太麻烦了。并且方块都是固定的，所以这些我们可以提前定义好。最终方块定义如下：
+
+from collections import namedtuple
+
+Point = namedtuple('Point', 'X Y')
+Block = namedtuple('Block', 'template start_pos end_pos name next')
+
+# S形方块
+S_BLOCK = [Block(['.00',
+                  '00.',
+                  '...'], Point(0, 0), Point(2, 1), 'S', 1),
+           Block(['0..',
+                  '00.',
+                  '.0.'], Point(0, 0), Point(1, 2), 'S', 0)]
+方块需要包含两个方法，获取随机一个方块和旋转时获取旋转后的方块
+
+BLOCKS = {'O': O_BLOCK,
+          'I': I_BLOCK,
+          'Z': Z_BLOCK,
+          'T': T_BLOCK,
+          'L': L_BLOCK,
+          'S': S_BLOCK,
+          'J': J_BLOCK}
+
+
+def get_block():
+    block_name = random.choice('OIZTLSJ')
+    b = BLOCKS[block_name]
+    idx = random.randint(0, len(b) - 1)
+    return b[idx]
+
+
+# 获取旋转后的方块
+def get_next_block(block):
+    b = BLOCKS[block.name]
+    return b[block.next]
+判断是否可以旋转，下落，移动的方法也很容易实现了
+
+def _judge(pos_x, pos_y, block):
+    nonlocal game_area
+    for _i in range(block.start_pos.Y, block.end_pos.Y + 1):
+        if pos_y + block.end_pos.Y >= BLOCK_HEIGHT:
+            return False
+        for _j in range(block.start_pos.X, block.end_pos.X + 1):
+            if pos_y + _i >= 0 and block.template[_i][_j] != '.' and game_area[pos_y + _i][pos_x + _j] != '.':
+                return False
+    return True
+停靠
+最后一个问题是停靠，当方块下落到底或者遇到别的方块之后，就不能在下落了。我将此称之为“停靠”，有个名字说起来也方便一点。
+
+首先是要判断是否可以停靠，停靠发生之后，就是将当前方块的非空点画到游戏区域上，说白了，就是将cur_block的非空点按对应位置复制到game_area里去。并且计算是否有一排被全部填满了，全部填满则消除。
+
+def _dock():
+    nonlocal cur_block, next_block, game_area, cur_pos_x, cur_pos_y, game_over
+    for _i in range(cur_block.start_pos.Y, cur_block.end_pos.Y + 1):
+        for _j in range(cur_block.start_pos.X, cur_block.end_pos.X + 1):
+            if cur_block.template[_i][_j] != '.':
+                game_area[cur_pos_y + _i][cur_pos_x + _j] = '0'
+    if cur_pos_y + cur_block.start_pos.Y <= 0:
+        game_over = True
+    else:
+        # 计算消除
+        remove_idxs = []
+        for _i in range(cur_block.start_pos.Y, cur_block.end_pos.Y + 1):
+            if all(_x == '0' for _x in game_area[cur_pos_y + _i]):
+                remove_idxs.append(cur_pos_y + _i)
+        if remove_idxs:
+            # 消除
+            _i = _j = remove_idxs[-1]
+            while _i >= 0:
+                while _j in remove_idxs:
+                    _j -= 1
+                if _j < 0:
+                    game_area[_i] = ['.'] * BLOCK_WIDTH
+                else:
+                    game_area[_i] = game_area[_j]
+                _i -= 1
+                _j -= 1
+        cur_block = next_block
+        next_block = blocks.get_block()
+        cur_pos_x, cur_pos_y = (BLOCK_WIDTH - cur_block.end_pos.X - 1) // 2, -1 - cur_block.end_pos.Y
+至此，整个俄罗斯方块的主体功能就算是完成了。
+
+这里很多参数是可以调的，例如觉得旋转别扭，可以直接调整方块的定义，而无需去改动代码逻辑。
+
+
+
+------------------ 原始邮件 ------------------
+发件人: "上善若水"<2812139581@qq.com>;
+发送时间: 2020年7月23日(星期四) 晚上7:28
+收件人: "上善若水"<2812139581@qq.com>;
+主题: 俄罗斯方块
+
+#_*_ coding:utf-8 _*_
+'''
+Created on 2017年7月30日上午11:16:44
+
+@author: xiaolin
+
+relief=RAISED
+sticky=N+E+S+W
+'''
+from Tkinter import *
+import random
+import time
+from tkMessageBox import *
+
+
+#俄罗斯方块界面的高度
+HEIGHT  = 20
+
+#俄罗斯方块界面的宽度
+WIDTH   = 10
+
+ACTIVE  = 1
+PASSIVE = 0
+TRUE    = 1
+FALSE   = 0
+
+style = [
+            [[(0,0),(0,1),(1,1),(2,1)],[(1,0),(1,1),(1,2),(0,2)],[(0,1),(1,1),(2,1),(2,2)],[(1,0),(2,0),(1,1),(1,2)]],#j
+            [[(1,0),(1,1),(1,2),(2,1)],[(1,0),(0,1),(1,1),(2,1)],[(1,0),(1,1),(1,2),(0,1)],[(0,1),(1,1),(2,1),(1,2)]],#T
+            [[(0,1),(1,1),(2,1),(2,0)],[(0,0),(1,0),(1,1),(1,2)],[(0,1),(1,1),(2,1),(0,2)],[(1,0),(1,1),(1,2),(2,2)]],#反L
+            [[(0,0),(0,1),(1,1),(1,2)],[(2,1),(1,1),(1,2),(0,2)],[(0,0),(0,1),(1,1),(1,2)],[(2,1),(1,1),(1,2),(0,2)]],#Z
+            [[(1,0),(1,1),(0,1),(0,2)],[(0,1),(1,1),(1,2),(2,2)],[(1,0),(1,1),(0,1),(0,2)],[(0,1),(1,1),(1,2),(2,2)]],#反Z
+            [[(0,0),(0,1),(1,1),(1,0)],[(0,0),(0,1),(1,1),(1,0)],[(0,0),(0,1),(1,1),(1,0)],[(0,0),(0,1),(1,1),(1,0)]],#田
+            [[(1,0),(1,1),(1,2),(1,3)],[(0,1),(1,1),(2,1),(3,1)],[(1,0),(1,1),(1,2),(1,3)],[(0,1),(1,1),(2,1),(3,1)]]#长条
+    ]
+
+root=Tk();
+root.title('俄罗斯方块')
+
+class App(Frame):
+    def __init__(self,master):
+        Frame.__init__(self)
+        master.bind('<Up>',self.Up)
+        master.bind('<Left>',self.Left)
+        master.bind('<Right>',self.Right)
+        master.bind('<Down>',self.Down)
+
+        master.bind('<space>',self.Space)
+        master.bind('<Control-Shift-Key-F12>',self.Play)
+        master.bind('<Key-P>',self.Pause)
+        master.bind('<Key-S>',self.StartByS)
+
+        # rgb颜色值
+        self.backg="#%02x%02x%02x" % (120,150,30)    #大背景
+        self.frontg="#%02x%02x%02x" % (40,120,150)    #下一个形状颜色
+        self.nextg="#%02x%02x%02x" % (150,100,100)    #小背景
+        self.flashg="#%02x%02x%02x" % (210,130,100)    #炸的颜色
+
+        self.LineDisplay=Label(master,text='Lines: ',bg='black',fg='red')
+        self.Line=Label(master,text='0',bg='black',fg='red')
+        self.ScoreDisplay=Label(master,text='Score: ',bg='black',fg='red')
+        self.Score=Label(master,text='0',bg='black',fg='red')
+        self.SpendTimeDisplay=Label(master,text='Time: ',bg='black',fg='red')
+        self.SpendTime=Label(master,text='0.0',bg='black',fg='red')
+
+        self.LineDisplay.grid(row=HEIGHT-2,column=WIDTH,columnspan=2)
+        self.Line.grid(row=HEIGHT-2,column=WIDTH+2,columnspan=3)
+        self.ScoreDisplay.grid(row=HEIGHT-1,column=WIDTH,columnspan=2)
+        self.Score.grid(row=HEIGHT-1,column=WIDTH+2,columnspan=3)
+        self.SpendTimeDisplay.grid(row=HEIGHT-4,column=WIDTH,columnspan=2)
+        self.SpendTime.grid(row=HEIGHT-4,column=WIDTH+2,columnspan=3)
+
+        self.TotalTime=0.0
+        self.TotalLine=0
+        self.TotalScore=0
+
+        #游戏结束
+        self.isgameover=FALSE
+        #暂停
+        self.isPause=FALSE
+        #开始
+        self.isStart=FALSE
+        self.NextList=[]        #整个小背景
+        self.NextRowList=[]     #一行小背景
+
+        self.px=0
+        self.py=0       #记录方块参考点
+
+        #渲染小背景
+        r=0;c=0
+        for k in range(4*4):
+            LN=Label(master,text='    ',bg=str(self.nextg),fg='white',relief=FLAT,bd=3)
+            LN.grid(row=r,column=WIDTH+c,sticky=N+E+S+W)
+            self.NextRowList.append(LN)
+            c=c+1
+            if c>=4:
+                r=r+1;c=0
+                self.NextList.append(self.NextRowList)
+                self.NextRowList=[]
+
+        #渲染大背景
+        self.BlockList=[]
+        self.BlockRowList=[]
+        self.LabelList=[]
+        self.LabelRowList=[]
+        row=0;col=0
+        for i in range(HEIGHT*WIDTH):
+            L=Label(master,text='    ',bg=str(self.backg),fg='white',relief=FLAT,bd=4)
+            L.grid(row=row,column=col,sticky=N+E+S+W)
+            L.row=row;L.col=col;L.isactive=PASSIVE
+            self.BlockRowList.append(0);    #大背景每个格子初始化为0值
+            self.LabelRowList.append(L)
+            col=col+1
+            if col>=WIDTH:
+                row=row+1;col=0
+                self.BlockList.append(self.BlockRowList)
+                self.LabelList.append(self.LabelRowList)
+                self.BlockRowList=[]
+                self.LabelRowList=[]
+
+        #file
+        fw=open('text.txt','a')
+        fw.close()
+        hasHead=FALSE
+        f=open('text.txt','r')
+        if f.read(5)=='score':
+            hasHead=TRUE
+        f.close()
+        self.file=open('text.txt','a')
+        if hasHead==FALSE:
+            self.file.write('score    line    time    scorePtime    linePtime    scorePline    date/n')
+            self.file.flush()
+
+        self.time=1000
+        self.OnTimer()
+
+    def __del__(self):
+        #self.file.close()
+        pass
+
+    def Pause(self,event):
+        self.isPause=1-self.isPause
+
+    def Up(self,event):
+        BL=self.BlockList   #格子的值
+        LL=self.LabelList   #格子Label
+
+        Moveable=TRUE       #是否可旋转
+
+        #代码编写开始
+        nowStyle = style[self.xnow][(self.ynow)]
+        newStyle = style[self.xnow][(self.ynow+1)%4]  #算出下一俄罗斯方块
+        self.ynow = (self.ynow+1)%4 #此行代码非常重要，否则响应UP时，只能变第一次
+
+        print("nowStyle:"+str(nowStyle)+"=====>>newStyle:"+str(newStyle))
+
+        #根据现有形状中每个label的坐标计算出旋转后目标坐标(x,y)
+        SourceList=[];DestList=[]
+
+        for i in range(4):
+            SourceList.append([ nowStyle[i][0]+self.px, nowStyle[i][1]+self.py])
+            x = newStyle[i][0]+self.px
+            y = newStyle[i][1]+self.py
+            DestList.append([x, y])
+
+            if x<0 or x>=HEIGHT or y<0 or y>=WIDTH : #or BL[x][y]==1 or LL[x][y].isactive==PASSIVE
+                Moveable=FALSE
+
+        if Moveable==TRUE:
+            for i in range(len(SourceList)):
+                self.Empty(SourceList[i][0],SourceList[i][1])
+            for i in range(len(DestList)):
+                self.Fill(DestList[i][0],DestList[i][1])
+
+    def Left(self,event):
+        BL=self.BlockList;LL=self.LabelList
+        Moveable=TRUE
+        for i in range(HEIGHT):
+            for j in range(WIDTH):
+                if LL[i][j].isactive==ACTIVE and j-1<0:Moveable=FALSE
+                if LL[i][j].isactive==ACTIVE and j-1>=0 and BL[i][j-1]==1 and LL[i][j-1].isactive==PASSIVE:Moveable=FALSE
+        if Moveable==TRUE:
+            self.py-=1
+            for i in range(HEIGHT):
+                for j in range(WIDTH):
+                    if j-1>=0 and LL[i][j].isactive==ACTIVE and BL[i][j-1]==0:
+                        self.Fill(i,j-1);self.Empty(i,j)
+
+    def Right(self,event):
+        BL=self.BlockList;LL=self.LabelList
+        Moveable=TRUE
+        for i in range(HEIGHT):
+            for j in range(WIDTH):
+                if LL[i][j].isactive==ACTIVE and j+1>=WIDTH:Moveable=FALSE
+                if LL[i][j].isactive==ACTIVE and j+1<WIDTH and BL[i][j+1]==1 and LL[i][j+1].isactive==PASSIVE:Moveable=FALSE
+        if Moveable==TRUE:
+            self.py+=1
+            for i in range(HEIGHT-1,-1,-1):
+                for j in range(WIDTH-1,-1,-1):
+                    if j+1<WIDTH and LL[i][j].isactive==ACTIVE and BL[i][j+1]==0:
+                        self.Fill(i,j+1);self.Empty(i,j)
+
+    def Down(self,event):
+        BL=self.BlockList;LL=self.LabelList
+        Moveable=TRUE
+        for i in range(HEIGHT):
+            for j in range(WIDTH):
+                if LL[i][j].isactive==ACTIVE and i+1>=HEIGHT:Moveable=FALSE
+                if LL[i][j].isactive==ACTIVE and i+1<HEIGHT and BL[i+1][j]==1 and LL[i+1][j].isactive==PASSIVE:Moveable=FALSE
+        if Moveable==TRUE and self.isStart :
+            self.px+=1
+            for i in range(HEIGHT-1,-1,-1):
+                for j in range(WIDTH-1,-1,-1):
+                    if i+1<HEIGHT and LL[i][j].isactive==ACTIVE and BL[i+1][j]==0:
+                        self.Fill(i+1,j);self.Empty(i,j);
+        if Moveable==FALSE:
+            for i in range(HEIGHT):
+                for j in range(WIDTH):
+                    LL[i][j].isactive=PASSIVE
+            self.JudgeLineFill()
+            self.Start()
+            if self.isgameover==TRUE:showinfo('T_T','The game is over!');self.Distroy();return FALSE
+            for i in range(4):
+                for j in range(4):
+                    self.NextEmpty(i,j)
+            self.Rnd()
+        return Moveable
+
+    def Space(self,event):
+        while 1:
+            if self.Down(0)==FALSE:break
+
+    def OnTimer(self):
+        if self.isStart==TRUE and self.isPause==FALSE:
+            self.TotalTime = self.TotalTime + float(self.time)/1000
+            self.SpendTime.config(text=str(self.TotalTime))
+
+        if self.isPause==FALSE:
+            self.Down(0)
+        if self.TotalScore>=1000:self.time=900
+        if self.TotalScore>=2000:self.time=750
+        if self.TotalScore>=3000:self.time=600
+        if self.TotalScore>=4000:self.time=400
+        self.after(self.time,self.OnTimer)      #随着分数增大，俄罗斯方块下降速度加快
+
+    def JudgeLineFill(self):
+        BL=self.BlockList;LL=self.LabelList
+        count=0;LineList=[]
+        for i in range(WIDTH):LineList.append(1)
+        #display flash
+        for i in range(HEIGHT):
+            if BL[i]==LineList:
+                count=count+1
+                for k in range(WIDTH):
+                    LL[i][k].config(bg=str(self.flashg))
+                    LL[i][k].update()
+        if count!=0:self.after(100)
+        #delete block
+        for i in range(HEIGHT):
+            if BL[i]==LineList:
+                #count=count+1
+                for j in range(i,0,-1):
+                    for k in range(WIDTH):
+                        BL[j][k]=BL[j-1][k]
+                        LL[j][k]['relief']=LL[j-1][k].cget('relief')
+                        LL[j][k]['bg']=LL[j-1][k].cget('bg')
+                for l in range(WIDTH):
+                    BL[0][l]=0
+                    LL[0][l].config(relief=FLAT,bg=str(self.backg))
+        self.TotalLine=self.TotalLine+count
+        if count==1:self.TotalScore=self.TotalScore+1*WIDTH
+        if count==2:self.TotalScore=self.TotalScore+3*WIDTH
+        if count==3:self.TotalScore=self.TotalScore+6*WIDTH
+        if count==4:self.TotalScore=self.TotalScore+10*WIDTH
+        self.Line.config(text=str(self.TotalLine))
+        self.Score.config(text=str(self.TotalScore))
+
+    def Fill(self,i,j):
+        if j<0:return
+        if self.BlockList[i][j]==1:self.isgameover=TRUE
+        self.BlockList[i][j]=1
+        self.LabelList[i][j].isactive=ACTIVE
+        self.LabelList[i][j].config(relief=RAISED,bg=str(self.frontg))
+
+    def Empty(self,i,j):
+        self.BlockList[i][j]=0
+        self.LabelList[i][j].isactive=PASSIVE
+        self.LabelList[i][j].config(relief=FLAT,bg=str(self.backg))
+
+    def Play(self,event):
+        showinfo('Made in China','^_^')
+
+    def NextFill(self,i,j):
+        self.NextList[i][j].config(relief=RAISED,bg=str(self.frontg))
+
+    def NextEmpty(self,i,j):
+        self.NextList[i][j].config(relief=FLAT,bg=str(self.nextg))
+
+    def Distroy(self):
+        #save
+        if self.TotalScore!=0:
+            #cehkongfu
+            savestr='%-9u%-8u%-8.2f%-14.2f%-13.2f%-14.2f%s/n' % (
+                self.TotalScore,self.TotalLine,self.TotalTime
+               ,self.TotalScore/self.TotalTime
+               ,self.TotalLine/self.TotalTime
+               ,float(self.TotalScore)/self.TotalLine
+               ,time.strftime('%Y-%m-%d %H:%M:%S',time.localtime()))
+            self.file.seek(0,2)
+            self.file.write(savestr)
+            self.file.flush()
+
+        for i in range(HEIGHT):
+            for j in range(WIDTH):
+                self.Empty(i,j)
+        self.TotalLine=0;self.TotalScore=0;self.TotalTime=0.0
+        self.Line.config(text=str(self.TotalLine))
+        self.Score.config(text=str(self.TotalScore))
+        self.SpendTime.config(text=str(self.TotalTime))
+        self.isgameover=FALSE
+        self.isStart=FALSE
+        self.time=1000
+        for i in range(4):
+            for j in range(4):
+                self.NextEmpty(i,j)
+
+    #游戏开始方块
+    def Start(self):
+        nextStyle = style[self.x][self.y]   #下一形状
+        self.xnow = self.x
+        self.ynow = self.y          #记录大背景中的方块
+        self.py = random.randint(0,6)
+        print("给py赋任意值:"+str(self.py))
+        self.px = 0
+        for ii in range(4):
+            self.Fill(int(nextStyle[ii][0]),int(nextStyle[ii][1])+self.py)
+        self.isStart=TRUE   #游戏开始
+
+    #预处理方块
+    def Rnd(self):
+        self.x=random.randint(0,6)
+        self.y=random.randint(0,3)
+        nextStyle = style[self.x][self.y]   #下一形状
+        for ii in range(4):
+            self.NextFill(int(nextStyle[ii][0]),int(nextStyle[ii][1]))
+
+    #游戏开始给出一次任意形状的方块
+    def RndFirst(self):
+        self.x=random.randint(0,6)  #选择第一个方块style
+        self.y=random.randint(0,3)
+
+    def Show(self):
+        self.file.seek(0)
+        strHeadLine=self.file.readline()
+        dictLine={}
+        strTotalLine=''
+        for OneLine in self.file.readlines():
+            temp=int(OneLine[:5])
+            dictLine[temp]=OneLine
+
+        list=sorted(dictLine.items(),key=lambda d:d[0])
+        ii=0
+        for onerecord in reversed(list):
+            ii=ii+1
+            if ii<11:
+                strTotalLine+=onerecord[1]
+        showinfo('Ranking', strHeadLine+strTotalLine)
+
+    def StartByS(self,event):
+        self.RndFirst()
+        self.Start()
+        self.Rnd()
+
+def Start():
+    app.RndFirst()
+    app.Start()
+    app.Rnd()
+
+def End():
+    app.Distroy()
+
+def Set():
+    print("设置功能待完善...")
+
+def Show():
+    app.Show()
+
+#主菜单
+mainmenu=Menu(root)
+root['menu']=mainmenu
+
+#二级菜单：game
+gamemenu=Menu(mainmenu)
+mainmenu.add_cascade(label='游戏',menu=gamemenu)
+gamemenu.add_command(label='开始',command=Start)
+gamemenu.add_command(label='结束',command=End)
+gamemenu.add_separator()
+gamemenu.add_command(label='退出',command=root.quit)
+
+#二级菜单：set
+setmenu=Menu(mainmenu)
+mainmenu.add_cascade(label='设置',menu=setmenu)
+setmenu.add_command(label='设置',command=Set)
+
+#二级菜单：show
+showmenu=Menu(mainmenu)
+mainmenu.add_cascade(label='展示',menu=showmenu)
+showmenu.add_command(label='展示',command=Show)
+
+#绑定功能
+
+app=App(root)
+#程序入口
+root.mainloop()
\ No newline at end of file
Index: PythonCode/Game/飞机大战.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Game/飞机大战.py	(date 1602761536613)
+++ PythonCode/Game/飞机大战.py	(date 1602761536613)
@@ -0,0 +1,670 @@
+# # -*- coding:utf-8 -*-
+# import pygame
+# import sys
+# from pygame.locals import *
+# from pygame.font import *
+# import time
+# import random
+#
+#
+# class Hero(object):
+#     # 玩家 英雄类
+#     def __init__(self, screen_temp):
+#         self.x = 210
+#
+#         self.y = 700
+#         self.life = 21
+#         # self.life = 100
+#         self.image = pygame.image.load("./feiji/hero1.png")
+#         self.screen = screen_temp
+#         self.bullet_list = []  # 用来存储子弹对象的引用
+#         # 爆炸效果用的如下属性
+#         self.hit = False  # 表示是否要爆炸
+#         self.bomb_list = []  # 用来存储爆炸时需要的图片
+#         self.__create_images()  # 调用这个方法向bomb_list中添加图片
+#         self.image_num = 0  # 用来记录while True的次数,当次数达到一定值时才显示一张爆炸的图,然后清空,,当这个次数再次达到时,再显示下一个爆炸效果的图片
+#         self.image_index = 0  # 用来记录当前要显示的爆炸效果的图片的序号
+#
+#     def __create_images(self):
+#
+#         # 添加爆炸图片
+#         self.bomb_list.append(pygame.image.load("./feiji/hero_blowup_n1.png"))
+#         self.bomb_list.append(pygame.image.load("./feiji/hero_blowup_n2.png"))
+#         self.bomb_list.append(pygame.image.load("./feiji/hero_blowup_n3.png"))
+#         self.bomb_list.append(pygame.image.load("./feiji/hero_blowup_n4.png"))
+#
+#     def display(self):
+#
+#         # 显示玩家的飞机
+#         # 如果被击中,就显示爆炸效果,否则显示普通的飞机效果
+#         if self.hit == True:
+#             self.screen.blit(self.bomb_list[self.image_index], (self.x, self.y))  # (self.x, self.y)是指当前英雄的位置
+#             # blit方法 （一个对象，左上角位置）
+#             self.image_num += 1
+#             print(self.image_num)
+#             if self.image_num == 7:
+#                 self.image_num = 0
+#             self.image_index += 1
+#             print(self.image_index)  # 这里子弹打住英雄时没有被清除掉，所以打一下，就死了
+#             if self.image_index > 3:
+#                 time.sleep(1)
+#             exit()  # 调用exit让游戏退出
+#             # self.image_index = 0
+#         else:
+#             if self.x < 0:  # 控制英雄，不让它跑出界面
+#                 self.x = 0
+#             elif self.x > 382:
+#                 self.x = 382
+#             if self.y < 0:
+#                 self.y = 0
+#             elif self.y > 750:
+#                 self.y = 750
+#             self.screen.blit(self.image, (self.x, self.y))  # z这里是只要没有被打中，就一直是刚开始的样子
+#
+#         # 不管玩家飞机是否被击中,都要显示发射出去的子弹
+#         for bullet in self.bullet_list:
+#             bullet.display()
+#             bullet.move()
+#
+#     def move(self, move_x, move_y):
+#         self.x += move_x
+#
+#         self.y += move_y
+#
+#         def fire(self):
+#
+#         # 通过创建一个子弹对象,完成发射子弹
+#         bullet = Bullet(self.screen, self.x, self.y)  # 创建一个子弹对象
+#         self.bullet_list.append(bullet)
+#
+#     def bomb(self):
+#         self.hit = True
+#
+#     def judge(self):
+#         global life
+#
+#         if life <= 0:
+#             self.bomb()
+#
+#
+# class Bullet(object):
+#     # 玩家子弹类
+#     def __init__(self, screen_temp, x_temp, y_temp):
+#         self.x = x_temp + 40
+#
+#         self.y = y_temp - 20
+#         self.image = pygame.image.load("./feiji/bullet.png")
+#         self.screen = screen_temp
+#
+#     def display(self):
+#         self.screen.blit(self.image, (self.x, self.y))
+#
+#     def move(self):
+#         self.y -= 10
+#
+#
+# class Bullet_Enemy(object):
+#     # 敌机子弹类
+#     def __init__(self, screen_temp, x_temp, y_temp):
+#         self.x = x_temp + 25
+#
+#         self.y = y_temp + 30
+#         self.image = pygame.image.load("./feiji/bullet1.png")
+#         self.screen = screen_temp
+#
+#     def display(self):
+#         self.screen.blit(self.image, (self.x, self.y))
+#
+#     def move(self, hero):
+#         self.y += 10
+#
+#         global life
+#         if (hero.y <= self.y <= hero.y + 40) and (hero.x <= self.x and self.x <= hero.x + 100):
+#             # if self.y in range(hero.y, hero.y + 40) and self.x in range(hero.x, hero.x + 40):
+#             life -= 10
+#             # self.bullet_list.remove()
+#             print("---judge_enemy---")
+#             return True
+#         if life <= 0:
+#             hero.bomb()
+#         return False
+#
+#
+# class Bullet_Boss(object):
+#     # boss子弹类1
+#     def __init__(self, screen_temp, x_temp, y_temp):
+#         self.x = x_temp + 80
+#
+#         self.y = y_temp + 230
+#         self.image = pygame.image.load("./feiji/bullet2.png")
+#         self.screen = screen_temp
+#
+#     def display(self):
+#         self.screen.blit(self.image, (self.x, self.y))
+#
+#     def move(self, hero):
+#         self.y += 6
+#
+#         self.x += 2
+#         global life
+#         if (hero.y <= self.y and self.y <= hero.y + 40) and (hero.x <= self.x and self.x <= hero.x + 100):
+#             # if self.y in range(hero.y, hero.y + 40) and self.x in range(hero.x, hero.x + 40):
+#             life -= 20
+#             # self.bullet_list.remove()
+#             print("---judge_boss---")
+#             return True
+#         if life <= 0:
+#             hero.bomb()
+#         return False
+#
+#
+# class Bullet_Boss1(object):
+#     # boss子弹类2
+#     def __init__(self, screen_temp, x_temp, y_temp):
+#         self.x = x_temp + 80
+#
+#         self.y = y_temp + 230
+#         self.image = pygame.image.load("./feiji/bullet2.png")
+#         self.screen = screen_temp
+#
+#     def display(self):
+#         self.screen.blit(self.image, (self.x, self.y))
+#
+#     def move(self, hero):
+#         self.y += 6
+#
+#         self.x -= 2
+#         global life
+#         if (hero.y <= self.y and self.y <= hero.y + 40) and (hero.x <= self.x and self.x <= hero.x + 100):
+#             # if self.y in range(hero.y, hero.y + 40) and self.x in range(hero.x, hero.x + 40):
+#             life -= 20
+#             # self.bullet_list.remove()
+#             print("---judge_boss---")
+#             return True
+#         if life <= 0:
+#             hero.bomb()
+#         return False
+#
+#
+# class Bullet_Boss2(object):
+#     # boss子弹类3
+#     def __init__(self, screen_temp, x_temp, y_temp):
+#         self.x = x_temp + 80
+#
+#         self.y = y_temp + 230
+#         self.image = pygame.image.load("./feiji/bullet2.png")
+#         self.screen = screen_temp
+#
+#     def display(self):
+#         self.screen.blit(self.image, (self.x, self.y))
+#
+#     def move(self, hero):
+#         self.y += 6
+#
+#         global life
+#         if (hero.y <= self.y and self.y <= hero.y + 40) and (hero.x <= self.x and self.x <= hero.x + 100):
+#             # if self.y in range(hero.y, hero.y + 40) and self.x in range(hero.x, hero.x + 40):
+#             life -= 20
+#             # self.bullet_list.remove()
+#             print("---judge_boss---")
+#             return True
+#         if life <= 0:
+#             hero.bomb()
+#         return False
+#
+#
+# class Base(object):
+#     # 基类 类似于抽象类
+#     def __init__(self, screen_temp, x, y, image_name):
+#         self.x = x
+#
+#         self.y = y
+#         self.screen = screen_temp
+#         self.image = pygame.image.load(image_name)
+#         self.alive = True
+#
+#     def display(self):
+#         if self.alive == True:
+#             self.screen.blit(self.image, (self.x, self.y))
+#
+#     def move(self):
+#         self.y += 5
+#
+#
+# class bomb_bullet(Base):
+#     # 炸弹类
+#     def __init__(self, screen_temp):
+#         Base.__init__(self, screen_temp, random.randint(45, 400), 0, "./feiji/bomb.png")
+#
+#     def judge(self, hero):
+#         if (hero.y <= self.y and self.y <= hero.y + 40) and (hero.x <= self.x and self.x <= hero.x + 100):
+#             self.alive = False
+#             hero.bomb()
+#
+#         if self.y >= 850:
+#             # self.alive = False
+#             self.y = 0
+#             self.x = random.randint(45, 400)
+#             # print("bomb.y = %d"%self.y)
+#
+#
+# class supply(Base):
+#     # 补给类
+#     def __init__(self, screen_temp):
+#         Base.__init__(self, screen_temp, random.randint(45, 400), -300, "./feiji/bomb-1.gif")
+#
+#     def judge(self, hero):
+#         global life
+#
+#         if (hero.y <= self.y and self.y <= hero.y + 40) and (hero.x <= self.x and self.x <= hero.x + 100):
+#             self.alive = False
+#             life += 10
+#
+#         if self.y >= 1500:
+#             self.y = 0
+#             self.x = random.randint(45, 400)
+#             self.alive = True
+#
+#
+# class clear_bullet(Base):
+#     def __init__(self, screen_temp):
+#         Base.__init__(self, screen_temp, random.randint(45, 400), 0, "./feiji/bomb-2.gif")
+#
+#         self.alive = False
+#
+#     def judge(self, hero, enemies):
+#         global q
+#
+#         q += 1
+#         # self.move()
+#         if q == 20:
+#             # self.move()
+#             self.alive = True
+#             q = 0
+#             if (hero.y <= self.y and self.y <= hero.y + 40) and (hero.x <= self.x and self.x <= hero.x + 100):
+#                 self.alive = False
+#             for enemy in enemies:
+#                 var = enemy.hit == True
+#
+#
+# class EnemyPlane(object):
+#     # 敌机类
+#     def __init__(self, screen_temp):
+#         self.x = random.randint(15, 480)
+#
+#         self.y = 0
+#         self.image = pygame.image.load("./feiji/enemy0.png")
+#         self.screen = screen_temp
+#         self.bullet_list = []  # 用来存储子弹对象的引用
+#         # self.direction = "right"#用来设置这个飞机默认的移动方向
+#         self.hit = False
+#         self.bomb_list = []
+#         self.__create_images()
+#         self.image_num = 0
+#         self.image_index = 0
+#         # 利用产生的随机数，随机确定飞机初始移动方向
+#         self.k = random.randint(1, 20)
+#         if self.k <= 10:
+#             self.direction = "right"
+#         elif self.k > 10:
+#             self.direction = "left"
+#
+#     def display(self, hero):
+#
+#         # 显示敌人的飞机
+#         if not self.hit:
+#             self.screen.blit(self.image, (self.x, self.y))
+#         else:
+#             self.screen.blit(self.bomb_list[self.image_index], (self.x, self.y))
+#             self.image_num += 1
+#             if self.image_num == 3 and self.image_index < 3:
+#                 self.image_num = 0
+#             self.image_index += 1
+#             # print(self.image_index)
+#             # if self.image_index > 2:
+#             # time.sleep(0.1)
+#
+#         for bullet in self.bullet_list:
+#             bullet.display()
+#             if (bullet.move(hero)):
+#                 self.bullet_list.remove(bullet)
+#
+#     def move(self):
+#
+#         # 利用随机数来控制飞机移动距离，以及移动范围
+#         d1 = random.uniform(1, 3)
+#         d2 = random.uniform(0.2, 3)
+#         p1 = random.uniform(50, 100)
+#         p2 = random.uniform(-200, 0)
+#         if self.direction == "right":
+#             self.x += d1
+#         elif self.direction == "left":
+#             self.x -= d1
+#
+#         if self.x > 480 - p1:
+#             # 480 - 50
+#             self.direction = "left"
+#         elif self.x < p2:
+#             self.direction = "right"
+#         self.y += d2
+#
+#     def bomb(self):
+#         self.hit = True
+#
+#     def __create_images(self):
+#         self.bomb_list.append(pygame.image.load("./feiji/enemy0_down1.png"))
+#
+#         self.bomb_list.append(pygame.image.load("./feiji/enemy0_down2.png"))
+#         self.bomb_list.append(pygame.image.load("./feiji/enemy0_down3.png"))
+#         self.bomb_list.append(pygame.image.load("./feiji/enemy0_down4.png"))
+#
+#     def fire(self):
+#
+#         # 利用随机数来控制敌机的开火，1/80的概率
+#         s = random.randint(0, 800)
+#         bullet1 = Bullet_Enemy(self.screen, self.x, self.y)
+#         if s < 10:
+#             self.bullet_list.append(bullet1)
+#
+#
+# class EnemyPlanes(EnemyPlane):
+#     # 敌机群类 继承自EnemyPlane类
+#     def __init__(self, screen_temp):
+#         EnemyPlane.__init__(self, screen_temp)
+#
+#         self.num = 0
+#         self.enemy_list = []  # 用列表存储产生的多架敌机
+#         self.screen = screen_temp
+#
+#     def add_enemy(self, num):
+#
+#         # 产生多架敌机的函数
+#         self.num = num
+#         for i in range(num):
+#             enemy = EnemyPlane(self.screen)
+#             self.enemy_list.append(enemy)
+#
+#     def display(self, hero):
+#         for i in range(self.num):
+#             self.enemy_list[i].display(hero)
+#
+#     def move(self):
+#         for i in range(self.num):
+#             self.enemy_list[i].move()
+#
+#     def fire(self):
+#
+#         # s = random.randint(0,1000)
+#         for i in range(self.num):
+#             self.enemy_list[i].fire()
+#
+#
+# class Boss(EnemyPlane):
+#     # boss敌机类 继承自EnemyPlane类
+#     def __init__(self, screen_temp):
+#         EnemyPlane.__init__(self, screen_temp)
+#
+#         self.x = 150
+#         self.y = 0
+#         self.bomb_list = []
+#         self.__create_images()
+#         self.image = pygame.image.load("./feiji/enemy2.png")
+#         self.screen = screen_temp
+#         self.bullet_list = []
+#
+#     def __create_images(self):
+#
+#         # self.bomb_list.append(pygame.image.load("./feiji/enemy2.png"))
+#         self.bomb_list.append(pygame.image.load("./feiji/enemy2.png"))
+#         self.bomb_list.append(pygame.image.load("./feiji/enemy2_down1.png"))
+#         self.bomb_list.append(pygame.image.load("./feiji/enemy2_down2.png"))
+#         self.bomb_list.append(pygame.image.load("./feiji/enemy2_down3.png"))
+#         self.bomb_list.append(pygame.image.load("./feiji/enemy2_down4.png"))
+#         self.bomb_list.append(pygame.image.load("./feiji/enemy2_down5.png"))
+#         self.bomb_list.append(pygame.image.load("./feiji/enemy2_down6.png"))
+#
+#     def display(self, hero):
+#
+#         # 显示敌人的飞机
+#         global g
+#         # print(g)
+#         self.screen.blit(self.bomb_list[g], (self.x, self.y))
+#         for bullet in self.bullet_list:
+#             bullet.display()
+#             if (bullet.move(hero)):
+#                 self.bullet_list.remove(bullet)
+#
+#     def move(self):
+#         d1 = 0
+#
+#         self.y += 0
+#
+#     def fire(self):
+#         global s
+#
+#         s += 1
+#         bullet1 = Bullet_Boss(self.screen, self.x, self.y)
+#         bullet2 = Bullet_Boss1(self.screen, self.x, self.y)
+#         bullet3 = Bullet_Boss2(self.screen, self.x, self.y)
+#         if s == 20:
+#             s = 0
+#             self.bullet_list.append(bullet1)
+#             self.bullet_list.append(bullet2)
+#             self.bullet_list.append(bullet3)
+#
+#
+#     def judge1(hero, enemy):
+#         # 判断敌机的炸毁
+#         for bullet1 in hero.bullet_list:
+#             if bullet1.y in range(int(enemy.y), int(enemy.y + 30)) and bullet1.x in range(int(enemy.x - 10),
+#                                                                                           int(enemy.x + 50)):
+#                 hero.bullet_list.remove(bullet1)
+#                 enemy.bomb()
+#             if bullet1.y < 0 or bullet1.x < 0 or bullet1.x > 480:  # 删除越界的玩家子弹
+#                 hero.bullet_list.remove(bullet1)
+#
+#
+# def judge3(hero, boss):
+#     # 判断boss的炸毁
+#     global goal, g, goal0
+#     for bullet3 in hero.bullet_list:
+#         if bullet3.y in range(int(boss.y), int(boss.y + 60)) and bullet3.x in range(int(boss.x), int(boss.x + 100)):
+#             hero.bullet_list.remove(bullet3)
+#             g += 1
+#             boss.image = boss.bomb_list[g]
+#             print("g = %d" % g)
+#             if g >= 6:
+#                 boss.y, g, goal = 0, 0, 0
+#             boss.bomb()
+#             goal0 += 10
+#
+#
+# def clear_enemy(enemies):
+#     # 清除敌机群类中被炸毁的敌机
+#     global goal, goal0
+#     for enemy in enemies.enemy_list:
+#         if enemy.hit == True and enemy.image_index == 3:
+#             enemies.enemy_list.remove(enemy)
+#             enemies.num -= 1
+#             goal += 1
+#             goal0 += 5
+#             print("goal = %d" % goal)
+#         if enemy.y >= 850:
+#             enemies.enemy_list.remove(enemy)
+#             enemies.num -= 1
+#
+#
+# def judge_num(enemies):
+#     # 判断频幕上敌人的数量，如果为零，继续添加敌人
+#     n = random.randint(1, 5)
+#     if len(enemies.enemy_list) == 0:
+#         enemies.add_enemy(n)
+#
+#
+# def show_text(screen_temp):
+#     # 在屏幕上显示文字
+#     text = "GOAL:" + str(goal0) + "Life:" + str(life)
+#     font_size = 50
+#     pos = (0, 0)
+#     color = (0, 255, 0)
+#     cur_font = pygame.font.SysFont("宋体", font_size)
+#     text_fmt = cur_font.render(text, 1, color)
+#     screen_temp.blit(text_fmt, pos)
+#
+#
+# def creat_bomb(screen_temp):
+#     bomb = bomb_bullet(screen_temp)
+#     bomb_list = []
+#     bomb_list.apend(bomb)
+#
+#
+# # 定义的全局变量
+# goal = 0  # 玩家得分
+# goal0 = 0
+# g = 0  # 击中boss的次数
+# life = 100  # 生命值
+# s = 0  # 判断大boss是否发射子弹
+# q = 0
+#
+#
+# def main():
+#     # 主函数执行
+#     # 获取事件，比如按键等
+#     bb = False
+#     move_x = 0
+#     move_y = 0
+#     pygame.init()
+#     screen = pygame.display.set_mode((480, 852), 0, 32)
+#     #     210,400
+#     background = pygame.image.load("./feiji/background.png")
+#     pygame.display.set_caption("飞机大战")
+#     atlas = pygame.image.load("./feiji/New Atlas.png")
+#     # 创建玩家飞机
+#     hero = Hero(screen)
+#     # 创建敌机群
+#     enemis = EnemyPlanes(screen)
+#     enemis.add_enemy(5)
+#     # 创建boss对象
+#     boss = Boss(screen)
+#     # 创建炸弹对象
+#     bomb = bomb_bullet(screen)
+#     # 创建补给对象
+#     supply0 = supply(screen)
+#     clear = clear_bullet(screen)
+#     left_key, right_key, up_key, down_key, done = 0, 0, 0, 0, 0
+#     # mark = 0#用来判断boss发射子弹
+#     while True:
+#         if done:
+#             if done % 8 == 0:
+#                 done = 1
+#             hero.fire()
+#             else:
+#             done += 1
+#         for event in pygame.event.get():
+#             # 判断是否是点击了退出按钮
+#             if event.type == QUIT:
+#                 print("exit")
+#             exit()
+#             # 判断是否是按下了键
+#             if event.type == KEYDOWN:
+#             # down
+#             # 检测按键是否是a或者left
+#
+#             if event.key == K_a or event.key == K_LEFT:
+#                 # print('left')
+#                 move_x = -5
+#                 left_key += 1
+#
+#             # 检测按键是否是d或者right
+#             elif event.key == K_d or event.key == K_RIGHT:
+#                 # print('right')
+#                 move_x = 5
+#                 right_key += 1
+#
+#             elif event.key == K_w or event.key == K_UP:
+#                 move_y = -5
+#                 up_key += 1
+#
+#             elif event.key == K_s or event.key == K_DOWN:
+#                 move_y = 5
+#                 down_key += 1
+#
+#             # 检测按键是否是空格键
+#             elif event.key == K_SPACE:
+#                 # print('space')
+#                 hero.fire()
+#                 done = 1
+#                 # enemis.fire()
+#
+#             elif event.key == K_b:
+#                 print('b')
+#                 hero.bomb()
+#
+#             if event.type == KEYUP:
+#                 if event.key == K_a or event.key == K_LEFT:
+#                     left_key -= 1
+#                     if right_key == 0:
+#                         move_x = 0
+#                     else:
+#                         move_x = 5
+#
+#             if event.key == K_d or event.key == K_RIGHT:
+#                 right_key -= 1
+#                 if left_key == 0:
+#                     move_x = 0
+#                 else:
+#                     move_x = -5
+#
+#             if event.key == K_w or event.key == K_UP:
+#                 up_key -= 1
+#                 if down_key == 0:
+#                     move_y = 0
+#                 else:
+#                     move_y = 5
+#
+#             if event.key == K_s or event.key == K_DOWN:
+#                 down_key -= 1
+#                 if up_key == 0:
+#                     move_y = 0
+#                 else:
+#                     move_y = -5
+#
+#             if event.key == K_SPACE:
+#                 done = 0
+#
+#         screen.blit(background, (0, 0))
+#         hero.move(move_x, move_y)
+#         hero.display()
+#         hero.judge()
+#         enemis.display(hero)
+#         enemis.move()
+#         enemis.fire()
+#         bomb.display()
+#         bomb.judge(hero)
+#         bomb.move()
+#         supply0.display()
+#         supply0.judge(hero)
+#         supply0.move()
+#         # clear.display()
+#         # clear.judge(hero, enemis)
+#         # clear.move()
+#         for i in range(enemis.num):
+#             # judge1(hero, enemis.enemy_list[i])
+#             # enemis.enemy_list[i].judge(hero)
+#         clear_enemy(enemis)
+#         judge_num(enemis)
+#         show_text(screen)
+#         if goal >= 15:
+#             boss.display(hero)
+#             boss.move()
+#             # mark+=1
+#             # if mark==8:
+#             boss.fire()
+#             # mark = 0
+#             # boss.judge
+#             judge3(hero, boss)
+#         pygame.display.update()
+#
+#
+# if __name__ == "__main__":
+#     main()
\ No newline at end of file
Index: PythonCode/Game/飞机大战实现过程
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Game/飞机大战实现过程	(date 1602761759239)
+++ PythonCode/Game/飞机大战实现过程	(date 1602761759239)
@@ -0,0 +1,922 @@
+python版本为3.5，需要安装pygame模块，完整代码如下。
+
+1.工具类plane_sprites.py
+
+import random
+import pygame
+
+# 屏幕大小的常量
+SCREEN_RECT = pygame.Rect(0, 0, 480, 700)
+# 刷新的帧率
+FRAME_PER_SEC = 60
+# 创建敌机的定时器常量
+CREATE_ENEMY_EVENT = pygame.USEREVENT
+# 英雄发射子弹事件
+HERO_FIRE_EVENT = pygame.USEREVENT + 1
+
+
+class GameSprite(pygame.sprite.Sprite):
+    """飞机大战游戏精灵"""
+
+    def __init__(self, image_name, speed=1):
+
+        # 调用父类的初始化方法
+        super().__init__()
+
+        # 定义对象的属性
+        self.image = pygame.image.load(image_name)
+        self.rect = self.image.get_rect()
+        self.speed = speed
+
+    def update(self):
+
+        # 在屏幕的垂直方向上移动
+        self.rect.y += self.speed
+
+
+class Background(GameSprite):
+    """游戏背景精灵"""
+
+    def __init__(self, is_alt=False):
+
+        # 1. 调用父类方法实现精灵的创建(image/rect/speed)
+        super().__init__("./images/background.png")
+
+        # 2. 判断是否是交替图像，如果是，需要设置初始位置
+        if is_alt:
+            self.rect.y = -self.rect.height
+
+    def update(self):
+
+        # 1. 调用父类的方法实现
+        super().update()
+
+        # 2. 判断是否移出屏幕，如果移出屏幕，将图像设置到屏幕的上方
+        if self.rect.y >= SCREEN_RECT.height:
+            self.rect.y = -self.rect.height
+
+
+class Enemy(GameSprite):
+    """敌机精灵"""
+
+    def __init__(self):
+
+        # 1. 调用父类方法，创建敌机精灵，同时指定敌机图片
+        super().__init__("./images/enemy1.png")
+
+        # 2. 指定敌机的初始随机速度 1 ~ 3
+        self.speed = random.randint(1, 3)
+
+        # 3. 指定敌机的初始随机位置
+        self.rect.bottom = 0
+
+        max_x = SCREEN_RECT.width - self.rect.width
+        self.rect.x = random.randint(0, max_x)
+
+    def update(self):
+
+        # 1. 调用父类方法，保持垂直方向的飞行
+        super().update()
+
+        # 2. 判断是否飞出屏幕，如果是，需要从精灵组删除敌机
+        if self.rect.y >= SCREEN_RECT.height:
+            # print("飞出屏幕，需要从精灵组删除...")
+            # kill方法可以将精灵从所有精灵组中移出，精灵就会被自动销毁
+            self.kill()
+
+    def __del__(self):
+        # print("敌机挂了 %s" % self.rect)
+        pass
+
+
+class Hero(GameSprite):
+    """英雄精灵"""
+
+    def __init__(self):
+
+        # 1. 调用父类方法，设置image&speed
+        super().__init__("./images/me1.png", 0)
+
+        # 2. 设置英雄的初始位置
+        self.rect.centerx = SCREEN_RECT.centerx
+        self.rect.bottom = SCREEN_RECT.bottom - 120
+
+        # 3. 创建子弹的精灵组
+        self.bullets = pygame.sprite.Group()
+
+    def update(self):
+
+        # 英雄在水平方向移动
+        self.rect.x += self.speed
+
+        # 控制英雄不能离开屏幕
+        if self.rect.x < 0:
+            self.rect.x = 0
+        elif self.rect.right > SCREEN_RECT.right:
+            self.rect.right = SCREEN_RECT.right
+
+    def fire(self):
+        print("发射子弹...")
+
+        for i in (0, 1, 2):
+            # 1. 创建子弹精灵
+            bullet = Bullet()
+
+            # 2. 设置精灵的位置
+            bullet.rect.bottom = self.rect.y - i * 20
+            bullet.rect.centerx = self.rect.centerx
+
+            # 3. 将精灵添加到精灵组
+            self.bullets.add(bullet)
+
+
+class Bullet(GameSprite):
+    """子弹精灵"""
+
+    def __init__(self):
+
+        # 调用父类方法，设置子弹图片，设置初始速度
+        super().__init__("./images/bullet1.png", -2)
+
+    def update(self):
+
+        # 调用父类方法，让子弹沿垂直方向飞行
+        super().update()
+
+        # 判断子弹是否飞出屏幕
+        if self.rect.bottom < 0:
+            self.kill()
+
+    def __del__(self):
+        print("子弹被销毁...")
+
+
+2.主类plane_main.py
+
+import pygame
+from plane_sprites import *
+
+
+class PlaneGame(object):
+    """飞机大战主游戏"""
+
+    def __init__(self):
+        print("游戏初始化")
+
+        # 1. 创建游戏的窗口
+        self.screen = pygame.display.set_mode(SCREEN_RECT.size)
+        # 2. 创建游戏的时钟
+        self.clock = pygame.time.Clock()
+        # 3. 调用私有方法，精灵和精灵组的创建
+        self.__create_sprites()
+
+        # 4. 设置定时器事件 - 创建敌机　1s
+        pygame.time.set_timer(CREATE_ENEMY_EVENT, 1000)
+        pygame.time.set_timer(HERO_FIRE_EVENT, 500)
+
+    def __create_sprites(self):
+
+        # 创建背景精灵和精灵组
+        bg1 = Background()
+        bg2 = Background(True)
+
+        self.back_group = pygame.sprite.Group(bg1, bg2)
+
+        # 创建敌机的精灵组
+        self.enemy_group = pygame.sprite.Group()
+
+        # 创建英雄的精灵和精灵组
+        self.hero = Hero()
+        self.hero_group = pygame.sprite.Group(self.hero)
+
+    def start_game(self):
+        print("游戏开始...")
+
+        while True:
+            # 1. 设置刷新帧率
+            self.clock.tick(FRAME_PER_SEC)
+            # 2. 事件监听
+            self.__event_handler()
+            # 3. 碰撞检测
+            self.__check_collide()
+            # 4. 更新/绘制精灵组
+            self.__update_sprites()
+            # 5. 更新显示
+            pygame.display.update()
+
+    def __event_handler(self):
+
+        for event in pygame.event.get():
+
+            # 判断是否退出游戏
+            if event.type == pygame.QUIT:
+                PlaneGame.__game_over()
+            elif event.type == CREATE_ENEMY_EVENT:
+                # print("敌机出场...")
+                # 创建敌机精灵
+                enemy = Enemy()
+
+                # 将敌机精灵添加到敌机精灵组
+                self.enemy_group.add(enemy)
+            elif event.type == HERO_FIRE_EVENT:
+                self.hero.fire()
+            # elif event.type == pygame.KEYDOWN and event.key == pygame.K_RIGHT:
+            #     print("向右移动...")
+
+        # 使用键盘提供的方法获取键盘按键 - 按键元组
+        keys_pressed = pygame.key.get_pressed()
+        # 判断元组中对应的按键索引值 1
+        if keys_pressed[pygame.K_RIGHT]:
+            self.hero.speed = 2
+        elif keys_pressed[pygame.K_LEFT]:
+            self.hero.speed = -2
+        else:
+            self.hero.speed = 0
+
+    def __check_collide(self):
+
+        # 1. 子弹摧毁敌机
+        pygame.sprite.groupcollide(self.hero.bullets, self.enemy_group, True, True)
+
+        # 2. 敌机撞毁英雄
+        enemies = pygame.sprite.spritecollide(self.hero, self.enemy_group, True)
+
+        # 判断列表时候有内容
+        if len(enemies) > 0:
+
+            # 让英雄牺牲
+            self.hero.kill()
+
+            # 结束游戏
+            PlaneGame.__game_over()
+
+    def __update_sprites(self):
+
+        self.back_group.update()
+        self.back_group.draw(self.screen)
+
+        self.enemy_group.update()
+        self.enemy_group.draw(self.screen)
+
+        self.hero_group.update()
+        self.hero_group.draw(self.screen)
+
+        self.hero.bullets.update()
+        self.hero.bullets.draw(self.screen)
+
+    @staticmethod
+    def __game_over():
+        print("游戏结束")
+
+        pygame.quit()
+        exit()
+
+if __name__ == '__main__':
+
+    # 创建游戏对象
+    game = PlaneGame()
+
+    # 启动游戏
+    game.start_game()
+
+3.图片如下：
+
+
+
+                                   background.png
+
+
+
+enemy1.png
+
+
+
+me1.png
+
+
+
+bullet1.png
+
+
+------------------ 原始邮件 ------------------
+发件人: "上善若水"<2812139581@qq.com>;
+发送时间: 2020年7月23日(星期四) 晚上7:57
+收件人: "上善若水"<2812139581@qq.com>;
+主题: 飞机大战
+
+# -*- coding:utf-8 -*-
+import pygame
+import sys
+from pygame.locals import *
+from pygame.font import *
+import time
+import random
+
+class Hero(object):
+ #玩家 英雄类
+ def __init__(self, screen_temp):
+ self.x = 210
+ self.y = 700
+ self.life = 21
+ # self.life = 100
+ self.image = pygame.image.load("./feiji/hero1.png")
+ self.screen = screen_temp
+ self.bullet_list = []#用来存储子弹对象的引用
+ #爆炸效果用的如下属性
+ self.hit = False #表示是否要爆炸
+ self.bomb_list = [] #用来存储爆炸时需要的图片
+ self.__create_images() #调用这个方法向bomb_list中添加图片
+ self.image_num = 0 #用来记录while True的次数,当次数达到一定值时才显示一张爆炸的图,然后清空,,当这个次数再次达到时,再显示下一个爆炸效果的图片
+ self.image_index = 0#用来记录当前要显示的爆炸效果的图片的序号
+
+ def __create_images(self):
+ #添加爆炸图片
+ self.bomb_list.append(pygame.image.load("./feiji/hero_blowup_n1.png"))
+ self.bomb_list.append(pygame.image.load("./feiji/hero_blowup_n2.png"))
+ self.bomb_list.append(pygame.image.load("./feiji/hero_blowup_n3.png"))
+ self.bomb_list.append(pygame.image.load("./feiji/hero_blowup_n4.png"))
+
+ def display(self):
+ #显示玩家的飞机
+ #如果被击中,就显示爆炸效果,否则显示普通的飞机效果
+ if self.hit == True:
+  self.screen.blit(self.bomb_list[self.image_index], (self.x, self.y))#(self.x, self.y)是指当前英雄的位置
+  #blit方法 （一个对象，左上角位置）
+  self.image_num += 1
+  print(self.image_num)
+  if self.image_num == 7:
+  self.image_num = 0
+  self.image_index += 1
+  print(self.image_index) #这里子弹打住英雄时没有被清除掉，所以打一下，就死了
+  if self.image_index > 3:
+  time.sleep(1)
+  exit()#调用exit让游戏退出
+  #self.image_index = 0
+ else:
+  if self.x< 0: #控制英雄，不让它跑出界面
+  self.x = 0
+  elif self.x > 382:
+  self.x = 382
+  if self.y < 0:
+  self.y = 0
+  elif self.y > 750:
+  self.y = 750
+  self.screen.blit(self.image,(self.x, self.y))#z这里是只要没有被打中，就一直是刚开始的样子
+
+ #不管玩家飞机是否被击中,都要显示发射出去的子弹
+ for bullet in self.bullet_list:
+  bullet.display()
+  bullet.move()
+
+ def move(self, move_x,move_y):
+ self.x += move_x
+ self.y += move_y
+
+ def fire(self):
+ #通过创建一个子弹对象,完成发射子弹
+ bullet = Bullet(self.screen, self.x, self.y)#创建一个子弹对象
+ self.bullet_list.append(bullet)
+
+ def bomb(self):
+ self.hit = True
+
+ def judge(self):
+ global life
+ if life <= 0:
+  self.bomb()
+
+class Bullet(object):
+ #玩家子弹类
+ def __init__(self, screen_temp, x_temp, y_temp):
+ self.x = x_temp + 40
+ self.y = y_temp - 20
+ self.image = pygame.image.load("./feiji/bullet.png")
+ self.screen = screen_temp
+
+ def display(self):
+ self.screen.blit(self.image, (self.x, self.y))
+
+ def move(self):
+ self.y -= 10
+
+class Bullet_Enemy(object):
+ #敌机子弹类
+ def __init__(self, screen_temp, x_temp, y_temp):
+ self.x = x_temp + 25
+ self.y = y_temp + 30
+ self.image = pygame.image.load("./feiji/bullet1.png")
+ self.screen = screen_temp
+
+ def display(self):
+ self.screen.blit(self.image,(self.x,self.y))
+
+ def move(self, hero):
+ self.y += 10
+ global life
+ if (hero.y <= self.y and self.y <= hero.y + 40) and (hero.x <= self.x and self.x <= hero.x + 100):
+ #if self.y in range(hero.y, hero.y + 40) and self.x in range(hero.x, hero.x + 40):
+  life -= 10
+  #self.bullet_list.remove()
+  print("---judge_enemy---")
+  return True
+  if life<=0:
+  hero.bomb()
+ return False
+
+class Bullet_Boss(object):
+ #boss子弹类1
+ def __init__(self, screen_temp, x_temp, y_temp):
+ self.x = x_temp + 80
+ self.y = y_temp + 230
+ self.image = pygame.image.load("./feiji/bullet2.png")
+ self.screen = screen_temp
+
+ def display(self):
+ self.screen.blit(self.image, (self.x, self.y))
+
+ def move(self, hero):
+ self.y += 6
+ self.x += 2
+ global life
+ if (hero.y <= self.y and self.y <= hero.y + 40) and (hero.x <= self.x and self.x <= hero.x + 100):
+ #if self.y in range(hero.y, hero.y + 40) and self.x in range(hero.x, hero.x + 40):
+  life -= 20
+  #self.bullet_list.remove()
+  print("---judge_boss---")
+  return True
+  if life<=0:
+  hero.bomb()
+ return False
+
+class Bullet_Boss1(object):
+ #boss子弹类2
+ def __init__(self, screen_temp, x_temp, y_temp):
+ self.x = x_temp + 80
+ self.y = y_temp + 230
+ self.image = pygame.image.load("./feiji/bullet2.png")
+ self.screen = screen_temp
+
+ def display(self):
+ self.screen.blit(self.image, (self.x, self.y))
+
+ def move(self, hero):
+ self.y += 6
+ self.x -= 2
+ global life
+ if (hero.y <= self.y and self.y <= hero.y + 40) and (hero.x <= self.x and self.x <= hero.x + 100):
+ #if self.y in range(hero.y, hero.y + 40) and self.x in range(hero.x, hero.x + 40):
+  life -= 20
+  #self.bullet_list.remove()
+  print("---judge_boss---")
+  return True
+  if life<=0:
+  hero.bomb()
+ return False
+
+class Bullet_Boss2(object):
+ #boss子弹类3
+ def __init__(self, screen_temp, x_temp, y_temp):
+ self.x = x_temp + 80
+ self.y = y_temp + 230
+ self.image = pygame.image.load("./feiji/bullet2.png")
+ self.screen = screen_temp
+
+ def display(self):
+ self.screen.blit(self.image, (self.x, self.y))
+
+ def move(self, hero):
+ self.y += 6
+ global life
+ if (hero.y <= self.y and self.y <= hero.y + 40) and (hero.x <= self.x and self.x <= hero.x + 100):
+ #if self.y in range(hero.y, hero.y + 40) and self.x in range(hero.x, hero.x + 40):
+  life -= 20
+  #self.bullet_list.remove()
+  print("---judge_boss---")
+  return True
+  if life<=0:
+  hero.bomb()
+ return False
+
+class Base(object):
+ #基类 类似于抽象类
+ def __init__(self, screen_temp, x, y, image_name):
+ self.x = x
+ self.y = y
+ self.screen = screen_temp
+ self.image = pygame.image.load(image_name)
+ self.alive = True
+
+ def display(self):
+ if self.alive == True:
+  self.screen.blit(self.image, (self.x, self.y))
+
+ def move(self):
+ self.y += 5
+
+class bomb_bullet(Base):
+ #炸弹类
+ def __init__(self, screen_temp):
+ Base.__init__(self, screen_temp, random.randint(45, 400), 0, "./feiji/bomb.png")
+
+ def judge(self, hero):
+ if (hero.y <= self.y and self.y <= hero.y + 40) and (hero.x <= self.x and self.x <= hero.x + 100):
+  self.alive = False
+  hero.bomb()
+
+ if self.y >= 850:
+  #self.alive = False
+  self.y = 0
+  self.x = random.randint(45, 400)
+  #print("bomb.y = %d"%self.y)
+
+class supply(Base):
+ #补给类
+ def __init__(self, screen_temp):
+ Base.__init__(self, screen_temp, random.randint(45, 400), -300, "./feiji/bomb-1.gif")
+
+ def judge(self, hero):
+ global life
+ if (hero.y <= self.y and self.y <= hero.y + 40) and (hero.x <= self.x and self.x <= hero.x + 100):
+  self.alive = False
+  life += 10
+
+ if self.y >= 1500:
+  self.y = 0
+  self.x = random.randint(45, 400)
+  self.alive = True
+
+class clear_bullet(Base):
+ def __init__(self, screen_temp):
+ Base.__init__(self, screen_temp, random.randint(45, 400), 0, "./feiji/bomb-2.gif")
+ self.alive = False
+
+ def judge(self, hero, enemies):
+ global q
+ q += 1
+ #self.move()
+ if q == 20:
+  #self.move()
+  self.alive = True
+  q = 0
+  if (hero.y <= self.y and self.y <= hero.y + 40) and (hero.x <= self.x and self.x <= hero.x + 100):
+  self.alive = False
+  for enemy in enemies:
+   enemy.hit == True
+
+
+class EnemyPlane(object):
+ #敌机类
+ def __init__(self, screen_temp):
+ self.x = random.randint(15, 480)
+ self.y = 0
+ self.image = pygame.image.load("./feiji/enemy0.png")
+ self.screen = screen_temp
+ self.bullet_list = []#用来存储子弹对象的引用
+ #self.direction = "right"#用来设置这个飞机默认的移动方向
+ self.hit = False
+ self.bomb_list = []
+ self.__create_images()
+ self.image_num = 0
+ self.image_index = 0
+ #利用产生的随机数，随机确定飞机初始移动方向
+ self.k = random.randint(1, 20)
+ if self.k <= 10:
+  self.direction = "right"
+ elif self.k > 10:
+  self.direction = "left"
+
+ def display(self, hero):
+ #显示敌人的飞机
+ if not self.hit:
+  self.screen.blit(self.image, (self.x,self.y))
+ else:
+  self.screen.blit(self.bomb_list[self.image_index], (self.x,self.y))
+  self.image_num += 1
+  if self.image_num == 3 and self.image_index < 3:
+  self.image_num = 0
+  self.image_index += 1
+  #print(self.image_index)
+  # if self.image_index > 2:
+  # time.sleep(0.1)
+
+ for bullet in self.bullet_list:
+  bullet.display()
+  if(bullet.move(hero)):
+  self.bullet_list.remove(bullet)
+
+ def move(self):
+ #利用随机数来控制飞机移动距离，以及移动范围
+ d1 = random.uniform(1,3)
+ d2 = random.uniform(0.2,3)
+ p1 = random.uniform(50,100)
+ p2 = random.uniform(-200,0)
+ if self.direction == "right":
+  self.x += d1
+ elif self.direction == "left":
+  self.x -= d1
+
+ if self.x > 480 - p1:
+  #480 - 50
+  self.direction="left"
+ elif self.x < p2:
+  self.direction = "right"
+ self.y += d2
+
+ def bomb(self):
+ self.hit = True
+
+ def __create_images(self):
+ self.bomb_list.append(pygame.image.load("./feiji/enemy0_down1.png"))
+ self.bomb_list.append(pygame.image.load("./feiji/enemy0_down2.png"))
+ self.bomb_list.append(pygame.image.load("./feiji/enemy0_down3.png"))
+ self.bomb_list.append(pygame.image.load("./feiji/enemy0_down4.png"))
+
+ def fire(self):
+ #利用随机数来控制敌机的开火，1/80的概率
+ s = random.randint(0,800)
+ bullet1 = Bullet_Enemy(self.screen, self.x, self.y)
+ if s < 10:
+  self.bullet_list.append(bullet1)
+
+class EnemyPlanes(EnemyPlane):
+ #敌机群类 继承自EnemyPlane类
+ def __init__(self, screen_temp):
+ EnemyPlane.__init__(self, screen_temp)
+ self.num = 0
+ self.enemy_list = [] #用列表存储产生的多架敌机
+ self.screen = screen_temp
+
+ def add_enemy(self, num):
+ #产生多架敌机的函数
+ self.num = num
+ for i in range(num):
+  enemy = EnemyPlane(self.screen)
+  self.enemy_list.append(enemy)
+
+ def display(self, hero):
+ for i in range(self.num):
+  self.enemy_list[i].display(hero)
+
+ def move(self):
+ for i in range(self.num):
+  self.enemy_list[i].move()
+
+ def fire(self):
+ #s = random.randint(0,1000)
+ for i in range(self.num):
+  self.enemy_list[i].fire()
+
+class Boss(EnemyPlane):
+ #boss敌机类 继承自EnemyPlane类
+ def __init__(self,screen_temp):
+ EnemyPlane.__init__(self,screen_temp)
+ self.x = 150
+ self.y = 0
+ self.bomb_list = []
+ self.__create_images()
+ self.image = pygame.image.load("./feiji/enemy2.png")
+ self.screen = screen_temp
+ self.bullet_list = []
+
+ def __create_images(self):
+ #self.bomb_list.append(pygame.image.load("./feiji/enemy2.png"))
+ self.bomb_list.append(pygame.image.load("./feiji/enemy2.png"))
+ self.bomb_list.append(pygame.image.load("./feiji/enemy2_down1.png"))
+ self.bomb_list.append(pygame.image.load("./feiji/enemy2_down2.png"))
+ self.bomb_list.append(pygame.image.load("./feiji/enemy2_down3.png"))
+ self.bomb_list.append(pygame.image.load("./feiji/enemy2_down4.png"))
+ self.bomb_list.append(pygame.image.load("./feiji/enemy2_down5.png"))
+ self.bomb_list.append(pygame.image.load("./feiji/enemy2_down6.png"))
+
+ def display(self, hero):
+ #显示敌人的飞机
+ global g
+ #print(g)
+ self.screen.blit(self.bomb_list[g], (self.x,self.y))
+ for bullet in self.bullet_list:
+  bullet.display()
+  if(bullet.move(hero)):
+  self.bullet_list.remove(bullet)
+
+ def move(self):
+ d1 = 0
+ self.y += 0
+
+ def fire(self):
+ global s
+ s += 1
+ bullet1 = Bullet_Boss(self.screen, self.x, self.y)
+ bullet2 = Bullet_Boss1(self.screen, self.x, self.y)
+ bullet3 = Bullet_Boss2(self.screen, self.x, self.y)
+ if s == 20:
+  s = 0
+  self.bullet_list.append(bullet1)
+  self.bullet_list.append(bullet2)
+  self.bullet_list.append(bullet3)
+
+def judge1(hero,enemy):
+ #判断敌机的炸毁
+ for bullet1 in hero.bullet_list:
+ if bullet1.y in range(int(enemy.y),int(enemy.y + 30)) and bullet1.x in range(int(enemy.x-10),int(enemy.x + 50)):
+  hero.bullet_list.remove(bullet1)
+  enemy.bomb()
+ if bullet1.y < 0 or bullet1.x < 0 or bullet1.x > 480: #删除越界的玩家子弹
+  hero.bullet_list.remove(bullet1)
+
+def judge3(hero,boss):
+ #判断boss的炸毁
+ global goal, g, goal0
+ for bullet3 in hero.bullet_list:
+ if bullet3.y in range(int(boss.y), int(boss.y + 60)) and bullet3.x in range(int(boss.x), int(boss.x + 100)):
+  hero.bullet_list.remove(bullet3)
+  g += 1
+  boss.image = boss.bomb_list[g]
+  print("g = %d"%g)
+  if g >= 6:
+  boss.y, g, goal = 0, 0, 0
+  boss.bomb()
+  goal0 += 10
+
+def clear_enemy(enemies):
+ #清除敌机群类中被炸毁的敌机
+ global goal, goal0
+ for enemy in enemies.enemy_list:
+ if enemy.hit == True and enemy.image_index == 3:
+  enemies.enemy_list.remove(enemy)
+  enemies.num -= 1
+  goal += 1
+  goal0 += 5
+  print("goal = %d"%goal)
+ if enemy.y >= 850:
+  enemies.enemy_list.remove(enemy)
+  enemies.num -= 1
+
+def judge_num(enemies):
+ #判断频幕上敌人的数量，如果为零，继续添加敌人
+ n = random.randint(1,5)
+ if len(enemies.enemy_list) == 0:
+ enemies.add_enemy(n)
+
+def show_text(screen_temp):
+ #在屏幕上显示文字
+ text = "GOAL:" + str(goal0) + "Life:" + str(life)
+ font_size = 50
+ pos = (0,0)
+ color = (0,255,0)
+ cur_font = pygame.font.SysFont("宋体",font_size)
+ text_fmt = cur_font.render(text, 1, color)
+ screen_temp.blit(text_fmt, pos)
+
+def creat_bomb(screen_temp):
+ bomb = bomb_bullet(screen_temp)
+ bomb_list = []
+ bomb_list.apend(bomb)
+
+#定义的全局变量
+goal = 0 #玩家得分
+goal0 = 0
+g = 0 #击中boss的次数
+life = 100#生命值
+s = 0 #判断大boss是否发射子弹
+q = 0
+
+def main():
+ #主函数执行
+ #获取事件，比如按键等
+ bb = False
+ move_x = 0
+ move_y = 0
+ pygame.init()
+ screen = pygame.display.set_mode((480,852),0,32)
+ #     210,400
+ background = pygame.image.load("./feiji/background.png")
+ pygame.display.set_caption("飞机大战")
+ atlas = pygame.image.load("./feiji/New Atlas.png")
+ #创建玩家飞机
+ hero = Hero(screen)
+ #创建敌机群
+ enemis = EnemyPlanes(screen)
+ enemis.add_enemy(5)
+ #创建boss对象
+ boss = Boss(screen)
+ #创建炸弹对象
+ bomb = bomb_bullet(screen)
+ #创建补给对象
+ supply0 = supply(screen)
+ clear = clear_bullet(screen)
+ left_key, right_key, up_key, down_key, done = 0, 0, 0, 0, 0
+ # mark = 0#用来判断boss发射子弹
+ while True:
+ if done:
+  if done % 8 == 0:
+  done = 1
+  hero.fire()
+  else:
+  done += 1
+ for event in pygame.event.get():
+  #判断是否是点击了退出按钮
+  if event.type == QUIT:
+  print("exit")
+  exit()
+  #判断是否是按下了键
+  if event.type == KEYDOWN :
+  #down
+  #检测按键是否是a或者left
+
+  if event.key == K_a or event.key == K_LEFT:
+   #print('left')
+   move_x = -5
+   left_key += 1
+
+  #检测按键是否是d或者right
+  elif event.key == K_d or event.key == K_RIGHT:
+   #print('right')
+   move_x = 5
+   right_key += 1
+
+  elif event.key == K_w or event.key == K_UP:
+   move_y = -5
+   up_key += 1
+
+  elif event.key == K_s or event.key == K_DOWN:
+   move_y = 5
+   down_key += 1
+
+  #检测按键是否是空格键
+  elif event.key == K_SPACE:
+   #print('space')
+   hero.fire()
+   done = 1
+   #enemis.fire()
+
+  elif event.key == K_b:
+   print('b')
+   hero.bomb()
+
+  if event.type == KEYUP:
+  if event.key == K_a or event.key == K_LEFT:
+   left_key -= 1
+   if right_key == 0:
+   move_x = 0
+   else:
+   move_x = 5
+
+  if event.key == K_d or event.key == K_RIGHT:
+   right_key -= 1
+   if left_key == 0:
+   move_x = 0
+   else:
+   move_x = -5
+
+  if event.key == K_w or event.key == K_UP:
+   up_key -= 1
+   if down_key == 0:
+   move_y = 0
+   else:
+   move_y = 5
+
+  if event.key == K_s or event.key == K_DOWN:
+   down_key -= 1
+   if up_key == 0:
+   move_y = 0
+   else:
+   move_y = -5
+
+  if event.key == K_SPACE:
+   done = 0
+
+ screen.blit(background, (0, 0))
+ hero.move(move_x, move_y)
+ hero.display()
+ hero.judge()
+ enemis.display(hero)
+ enemis.move()
+ enemis.fire()
+ bomb.display()
+ bomb.judge(hero)
+ bomb.move()
+ supply0.display()
+ supply0.judge(hero)
+ supply0.move()
+ #clear.display()
+ #clear.judge(hero, enemis)
+ #clear.move()
+ for i in range(enemis.num):
+  judge1(hero, enemis.enemy_list[i])
+  #enemis.enemy_list[i].judge(hero)
+ clear_enemy(enemis)
+ judge_num(enemis)
+ show_text(screen)
+ if goal >= 15:
+  boss.display(hero)
+  boss.move()
+  # mark+=1
+  # if mark==8:
+  boss.fire()
+  # mark = 0
+  #boss.judge
+  judge3(hero, boss)
+ pygame.display.update()
+
+if __name__ == "__main__":
+ main()
\ No newline at end of file
Index: PythonCode/.idea/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/.idea/.gitignore	(date 1592138599702)
+++ PythonCode/.idea/.gitignore	(date 1592138599702)
@@ -0,0 +1,8 @@
+# Default ignored files
+/shelf/
+/workspace.xml
+# Datasource local storage ignored files
+/dataSources/
+/dataSources.local.xml
+# Editor-based HTTP Client requests
+/httpRequests/
Index: PythonCode/.idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/.idea/misc.xml	(date 1584440155446)
+++ PythonCode/.idea/misc.xml	(date 1584440155446)
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="JavaScriptSettings">
+    <option name="languageLevel" value="ES6" />
+  </component>
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.7 (code)" project-jdk-type="Python SDK" />
+</project>
\ No newline at end of file
Index: PythonCode/.idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/.idea/vcs.xml	(date 1602757220672)
+++ PythonCode/.idea/vcs.xml	(date 1602757220672)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$/.." vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/Game" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/Guoli-Zhang" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: PythonCode/.idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/.idea/modules.xml	(date 1591894898121)
+++ PythonCode/.idea/modules.xml	(date 1591894898121)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/code.iml" filepath="$PROJECT_DIR$/.idea/code.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
Index: PythonCode/.idea/code.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/.idea/code.iml	(date 1591894898094)
+++ PythonCode/.idea/code.iml	(date 1591894898094)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="PYTHON_MODULE" version="4">
+  <component name="NewModuleRootManager">
+    <content url="file://$MODULE_DIR$" />
+    <orderEntry type="jdk" jdkName="Python 3.7 (code)" jdkType="Python SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
Index: PythonCode/.idea/inspectionProfiles/profiles_settings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/.idea/inspectionProfiles/profiles_settings.xml	(date 1584440155471)
+++ PythonCode/.idea/inspectionProfiles/profiles_settings.xml	(date 1584440155471)
@@ -0,0 +1,6 @@
+<component name="InspectionProjectProfileManager">
+  <settings>
+    <option name="USE_PROJECT_PROFILE" value="false" />
+    <version value="1.0" />
+  </settings>
+</component>
\ No newline at end of file
Index: PythonCode/Basis/ThreeUnary.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Basis/ThreeUnary.py	(date 1593506544280)
+++ PythonCode/Basis/ThreeUnary.py	(date 1593506544280)
@@ -0,0 +1,10 @@
+# encoding:utf-8
+
+x = None
+y = x if x else 1
+z = x or 1
+print(y, z)
+
+if __name__ == "__main__":
+    print(b"\xE5\xAF\xAE")
+
Index: PythonCode/Basis/变量/全局变量.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Basis/变量/全局变量.py	(date 1591869694048)
+++ PythonCode/Basis/变量/全局变量.py	(date 1591869694048)
@@ -0,0 +1,6 @@
+a = 10
+for a in range(5):
+    print(a)
+print(a)
+
+# ---
Index: PythonCode/Basis/变量/互换.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Basis/变量/互换.py	(date 1591869694024)
+++ PythonCode/Basis/变量/互换.py	(date 1591869694024)
@@ -0,0 +1,13 @@
+a, b = 1, 2
+
+a += b
+b = a - b
+a -= b
+print(a, b)
+
+a ^= b
+b ^= a
+a ^= b
+print(a, b)
+
+a, b = b, a
Index: PythonCode/Basis/变量/习题集.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Basis/变量/习题集.py	(date 1591871616170)
+++ PythonCode/Basis/变量/习题集.py	(date 1591871616170)
@@ -0,0 +1,37 @@
+import functools
+
+list = range(101)
+
+result = functools.reduce(lambda i, j: i + j, list)
+print(result)
+
+spam = "Text spam"
+
+
+def scope_test():
+    def do_local():
+        spam = "local spam"
+
+    def do_nonlocal():
+        nonlocal spam
+        spam = "nonlocal spam"
+
+    def do_global():
+        global spam
+        spam = "global spam"
+
+    spam = "test spam"
+
+    do_local()
+
+    print("After local assignment:", spam)
+
+    do_nonlocal()
+    print("After nonlocal assignment:", spam)
+
+    do_global()
+    print("After global assignment:", spam)
+
+
+scope_test()
+print("After In global scope:", spam)
Index: PythonCode/Basis/拷贝/浅拷贝.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Basis/拷贝/浅拷贝.py	(date 1591871616126)
+++ PythonCode/Basis/拷贝/浅拷贝.py	(date 1591871616126)
@@ -0,0 +1,23 @@
+
+import copy
+
+a = [1, 2, 3, 4, ['a', 'b']]
+b = a
+c = copy.copy(a)
+d = copy.deepcopy(a)
+a.append(5)
+a[4].append('c')
+
+print(a, b, c, d)
+
+a = 1
+try:
+    a += 1
+except:
+    a += 1
+else:
+    a += 1
+finally:
+    a += 1
+
+print(a)
Index: PythonCode/Basis/拷贝/深拷贝.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Basis/拷贝/深拷贝.py	(date 1591871616108)
+++ PythonCode/Basis/拷贝/深拷贝.py	(date 1591871616108)
@@ -0,0 +1,23 @@
+
+import copy
+
+a = [1, 2, 3, 4, ['a', 'b']]
+b = a
+c = copy.copy(a)
+d = copy.deepcopy(a)
+a.append(5)
+a[4].append('c')
+
+print(a, b, c, d)
+
+a = 1
+try:
+    a += 1
+except:
+    a += 1
+else:
+    a += 1
+finally:
+    a += 1
+
+print(a)
Index: PythonCode/Basis/文件的操作/文件的读写.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Basis/文件的操作/文件的读写.py	(date 1591893583195)
+++ PythonCode/Basis/文件的操作/文件的读写.py	(date 1591893583195)
@@ -0,0 +1,53 @@
+
+
+import linecache
+# linecache.getline 第一参数是文件名，第二个参数是行编号。如果文件名不能直接找到的话，会从 sys.path 里找。
+# 如果请求的行数超过文件行数，函数不会报错，而是返回''空字符串。
+# 如果文件不存在，函数也不会报错，也返回''空字符串。
+
+the_line = linecache.getline("crack_click.py", 11)
+
+print(the_line)
+
+# linecache读取并缓存文件中所有的文本，
+# 若文件很大，而只读一行，则效率低下。
+# 可显示使用循环, 注意enumerate从0开始计数，而line_number从1开始
+
+
+def getline(the_file_path, line_number):
+    if line_number < 1:
+        return " "
+    for cur_line_number, line in enumerate(open(the_file_path, "rU")):
+        if cur_line_number == line_number - 1:
+            return line
+    return " "
+
+
+the_line = linecache.getline("crack_click.py", 30)
+
+print(the_line)
+
+
+#
+import os
+
+
+def print_directory_contents(sPath):
+    for sChild in os.listdir(sPath):
+        sChildPath = os.path.join(sPath, sChild)
+        if os.path.isdir(sChildPath):
+            print_directory_contents(sChildPath)
+        else:
+            print(sChildPath)
+
+def get_lines():
+    l = []
+    with open("file.txt", "rb") as f:
+        for eachline in f:
+            l.append(eachline)
+    return l
+
+if __name__ == "__main__":
+    for e in get_lines():
+        print("django, flask, rewuests, virtualenv, selenium, celery")
+
Index: PythonCode/Basis/Function_Def/Function_Def.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Basis/Function_Def/Function_Def.py	(date 1591892798283)
+++ PythonCode/Basis/Function_Def/Function_Def.py	(date 1591892798283)
@@ -0,0 +1,12 @@
+
+
+# 等级判断  0级：0~100, 1级：100~150, 2级：150~300, 3级：300~450, 4级：600
+def fun(score):
+    list = [100, 150, 300, 450, 600]
+    list.append(score)
+    list.sort()
+    return list.index(score)
+
+
+li = fun(151)
+print(li)
Index: PythonCode/Django/视图/函数视图.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Django/视图/函数视图.py	(date 1591869694018)
+++ PythonCode/Django/视图/函数视图.py	(date 1591869694018)
@@ -0,0 +1,6 @@
+# 函数视图：
+
+
+# def func(request):
+#     print(" ")
+#     return HttpResponse()
Index: PythonCode/Django/DjangoRESTframework/BookView.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Django/DjangoRESTframework/BookView.py	(date 1595039279786)
+++ PythonCode/Django/DjangoRESTframework/BookView.py	(date 1595039279786)
@@ -0,0 +1,12 @@
+from datetime import datetime
+from django.views import View
+
+
+class BooksAPIVIew(View):
+    def get(self, request):
+        """
+
+        :param request:
+        :return:
+        """
+    pass
\ No newline at end of file
Index: PythonCode/Django/视图/类视图.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Django/视图/类视图.py	(date 1591869694029)
+++ PythonCode/Django/视图/类视图.py	(date 1591869694029)
@@ -0,0 +1,7 @@
+# 类视图
+
+
+# class func(View):
+#     def get(self, request):
+#         print(" ")
+#         return HttpResponse()
Index: PythonCode/Container/Str/InterviewQuestions.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Container/Str/InterviewQuestions.py	(date 1591882019330)
+++ PythonCode/Container/Str/InterviewQuestions.py	(date 1591882019330)
@@ -0,0 +1,19 @@
+
+"""反转字符串"""
+
+print("aStr" [::-1])
+
+"""将字符串"k:1|k1:2|k2:3|k3:4"，处理成 Python 字典：{k:1， k1:2， ... } # 字典里的 K 作为字符串处理"""
+str1 = "k:1|k1:2|k2:3|k3:4"
+
+
+def str2dict(str1):
+    dict1 = {}
+    for iterms in str1.split("|"):
+        key, value = iterms.split(":")
+        dict1[key] = value
+    return dict1
+
+
+result = str2dict(str1)
+print(result)
Index: PythonCode/Container/Dict/Dict.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Container/Dict/Dict.py	(date 1591871616143)
+++ PythonCode/Container/Dict/Dict.py	(date 1591871616143)
@@ -0,0 +1,11 @@
+
+
+dict1 = {"大明": "宇森", "name": "杰森伯恩", "weight": 129}
+dict2 = {"学生": "杨昌明", "weight": 111, "age": 10}
+# dict1.setdefault("eight", 23)
+dict1.update(dict2)
+
+print(dict1.get("大明子"))
+
+print(dict1)
+
Index: PythonCode/Container/Dict/InterviewQuestions.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Container/Dict/InterviewQuestions.py	(date 1591871616163)
+++ PythonCode/Container/Dict/InterviewQuestions.py	(date 1591871616163)
@@ -0,0 +1,41 @@
+# 键值互换
+
+dict_old = {"1": 4, "2": 5, "3": 6}
+dict_new = dict([value, key] for key, value in dict_old.items())
+dict_New = dict(zip(dict_old.values(), dict_old.keys()))
+print(dict_new, dict_New)
+
+# ---
+A0 = dict(zip(('a', 'b', 'c', 'd', 'e'), (1, 2, 3, 4, 5)))
+A1 = range(10)
+A2 = [i for i in A1 if i in A0]
+A3 = [A0[s] for s in A0]
+A4 = [i for i in A1 if i in A3]
+A5 = {i: i * i for i in A1}
+A6 = [[i, i * i] for i in A1]
+
+print(f"A0={A0}", end=" ")
+print(" ")
+
+print(f"A1={A1}", end=" ")
+print(" ")
+
+print(f"A2={A2}", end=" ")
+print(" ")
+
+print(f"A3={A3}", end=" ")
+print(" ")
+
+print(f"A4={A4}", end=" ")
+print(" ")
+
+print(f"A5={A5}", end=" ")
+print(" ")
+
+print(f"A6={A6}", end=" ")
+print(" ")
+
+# 按值排序
+d = {"wd": 23, "gty": 57, "wdd": 25, "uji": 12, "wrt": 34}
+
+print(sorted(d.items(), key=lambda x: x[1]))
Index: PythonCode/Container/List/List.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Container/List/List.py	(date 1593064918560)
+++ PythonCode/Container/List/List.py	(date 1593064918560)
@@ -0,0 +1,52 @@
+# .insert(index, 数据)
+# .append(数据)
+# .extend(Iterable)
+# remove
+# clear()
+# .reverse()
+
+# .join(list)
+list1 = ["春花秋月何时了", "往事知多少", "小楼昨夜又东风", "任尔东西南北风"]
+str1 = " ".join(list1)
+print(str1)
+
+"""range:列表", "xrange：生成器", "linux:split"""
+print("range:列表", "xrange：生成器", "linux:split")
+
+for i in range(5, 0, -1):
+    print(i)
+
+
+l = []
+for i in range(10):
+    l.append({"num": i})
+print(l)
+# [{'num': 0}, {'num': 1}, {'num': 2}, {'num': 3}, {'num': 4}, {'num': 5}, {'num': 6}, {'num': 7}, {'num': 8}, {'num': 9}]
+
+ll = []
+a = {"num": 0}
+for i in range(10):
+    a["num"] = i
+    ll.append(a)
+print(ll)
+# >> [{'num': 9}, {'num': 9}, {'num': 9}, {'num': 9}, {'num': 9}, {'num': 9}, {'num': 9}, {'num': 9}, {'num': 9}, {'num': 9}]
+
+# 列表逆转
+a_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
+for j in range(len(a_list)):  # j =0
+    for i in a_list:  # i = [1, 2, 3]
+        print(i[j])
+
+# a_list.reverse()  # 列表逆转一
+# print(a_list)
+
+# print(a_list[::-1])  # 列表逆转二
+
+print(list(reversed(a_list)))  # 列表逆转三
+
+
+datalist = [21, 'python', 'java', 'javascript', 34, 'hello world']
+datalist[1:2] = 'only'
+datalist[1:3] = ['day']
+print(datalist)
+print(datalist[1:3])
\ No newline at end of file
Index: PythonCode/Container/List/InterviewQuestions.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Container/List/InterviewQuestions.py	(date 1591891151496)
+++ PythonCode/Container/List/InterviewQuestions.py	(date 1591891151496)
@@ -0,0 +1,13 @@
+
+"""请按 alist 中元素的 age 由大到小排序"""
+alist = [{'name': 'a', 'age': 20}, {'name': 'b', 'age': 30}, {'name': 'c', 'age': 25}]
+
+
+def sort_by_age(list1):
+    return sorted(alist, key=lambda x: x["age"], reverse=True)
+
+# 二维列表转置
+"""[[1, 2, 3], [4, 5, 6], [7, 8, 9]] >> [[1, 4, 7], [2, 5, 8], [3, 6, 9]]"""
+a_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
+t = [i for i in a_list]
+print([[i[j] for i in a_list] for j in range(len(a_list[0]))])
Index: PythonCode/Web_YunWei/Web_YunWei.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Web_YunWei/Web_YunWei.py	(date 1591885757947)
+++ PythonCode/Web_YunWei/Web_YunWei.py	(date 1591885757947)
@@ -0,0 +1,26 @@
+def mydecorator(func):
+    def wrapper(request, *args, **kwargs):
+        return func(request, *args, **kwargs)
+    return wrapper
+
+class FirstMixin(object):
+    @classmethod
+    def as_view(cls, *args, **kwargs):
+        view = super().as_view(*args, **kwargs)
+        return mydecorator(view)
+
+# class DemoView(FirstMixin, View):
+#     pass
+
+
+
+# user = User.object.filter(age__gt=F("id"))
+# and:  User.objects.filter(id__gt=1).filter(age__gt=10)
+# or:  User.objects.filter(Q(id__gt=1) | Q(age__lt=10))
+# not:  User.object.filter(~Q(id__gt=1))
+# User.objects.order_by("age") 默认升序
+# User.objects.order_by("-age") 降序
+# user = User.objects.get(id=1) user.books_set.all()
+
+# from django.core.cache import cache
+# cache.set(key, alue, 有效期)
\ No newline at end of file
Index: PythonCode/Def_Function/数学运算.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Def_Function/数学运算.py	(date 1593506544363)
+++ PythonCode/Def_Function/数学运算.py	(date 1593506544363)
@@ -0,0 +1,80 @@
+# -*- coding:utf-8 -*-
+
+# 最小公倍数
+from random import randint
+
+a, b = randint(1, 1000), randint(1, 1000)
+print(a, b)
+
+import math  # python3
+
+# print(math.gcd(a, b)) 最大公约数
+print(a * b / math.gcd(a, b))
+
+from fractions import _gcd  # python2
+
+print(a * b / _gcd(a, b))
+
+
+def soultion(a, b):
+    max_num, min_num = max(a, b), min(a, b)
+    for i in range(1, min_num + 1):
+        if max_num * i % min_num == 0:
+            print(i)
+            return max_num * i
+
+
+def gcd(a, b):
+    if a < b:
+        a, b = b, a
+    temp = a % b
+    if temp == 0:
+        return b
+    else:
+        return gcd(temp, b)
+
+
+def gcy(a, b):
+    temp = gcd(a, b)
+    return a * b / temp
+
+
+if __name__ == "__main__":
+    soultion = soultion(a, b)
+    temp = gcy(a, b)
+    print(f"{soultion}\n{temp}")
+
+# ^ 运算
+a = 2
+b = 3
+a = a ^ b
+print(a)
+
+b = b ^ a
+print(b)
+
+a = a ^ b
+print(a)
+
+# def feibo(num):
+
+e = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
+print(f"原数列：e={e}\n索引为奇数的数列：f={e[::2]}\n索引为偶数的数列：h={e[1::2]}")
+f = []
+h = []
+
+
+def fun(e):
+    for index in range(len(e)):
+        if index % 2 == 0:
+            f.append(e[index])
+        else:
+            h.append(e[index])
+    return f, h
+
+
+e = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
+k = fun(e)
+print(k)
+
+
Index: PythonCode/Def_Function/乘法表.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/Def_Function/乘法表.py	(date 1602496985485)
+++ PythonCode/Def_Function/乘法表.py	(date 1602496985485)
@@ -0,0 +1,21 @@
+import openpyxl
+# 工作簿
+workbook = openpyxl.Workbook()
+# 工作表
+worksheet = workbook.active
+# 创建九九乘法表
+nine_list = []
+for i in range(1, 10):
+    # 临时表，储存每一行
+    temp_list = []
+    for j in range(1, i + 1):
+        # 打印九九乘法表
+        print("{} x {} = {}".format(j, i, i * j), end='\t')
+        temp_list.append("{} x {} = {}".format(j, i, i * j))
+    nine_list.append(temp_list)
+    print()
+# 将九九乘法表批量写入到Excel中
+for i in nine_list:
+    worksheet.append(i)
+# 保存Excel
+workbook.save("九九乘法表.xlsx")
Index: PythonCode/FunctoolsLambda/Set/Set.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/FunctoolsLambda/Set/Set.py	(date 1591882927522)
+++ PythonCode/FunctoolsLambda/Set/Set.py	(date 1591882927522)
@@ -0,0 +1,21 @@
+
+list1 = [1, 2, 3]
+list2 = [3, 4, 5]
+
+set1 = set(list1)
+set2 = set(list2)
+
+print(set1 & set2)  # &：求同
+print(set1 ^ set2)  # ^：求异
+
+# 请写出一段 Python 代码实现删除一个 list 里面的重复元素?
+l1 = ['b', 'c', 'd', 'b', 'c', 'a', 'a']
+l2 = list(set(l1))
+print(l2)
+
+l3 = l2.sort(key=l1.index)
+print(l3)
+# >> None
+
+l4 = sorted(set(l1), key=l1.index)
+print(l2)
Index: PythonCode/FunctoolsLambda/TheLambda/TheLambda.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/FunctoolsLambda/TheLambda/TheLambda.py	(date 1592216499741)
+++ PythonCode/FunctoolsLambda/TheLambda/TheLambda.py	(date 1592216499741)
@@ -0,0 +1,25 @@
+# encoding:utf-8
+
+
+def my_function(func):
+
+    a = 100
+    b = 200
+    # 把 cucalate_rule 当做函数来调用
+    result = func(a, b)
+    print('result:', result)
+
+
+my_function(lambda a, b: a / b)
+my_function(lambda a, b: a // b)
+my_function(lambda a, b: a % b)
+
+
+# ---
+import functools
+list2 = []
+list2.append(functools.reduce(lambda i, j: j**3 - i**3, range(2)))
+print(list2)
+
+
+
Index: PythonCode/FunctoolsLambda/DerivedType/ListDerivedType.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/FunctoolsLambda/DerivedType/ListDerivedType.py	(date 1591892098824)
+++ PythonCode/FunctoolsLambda/DerivedType/ListDerivedType.py	(date 1591892098824)
@@ -0,0 +1,64 @@
+
+# [[0~10] * 10]
+print([x * 11 for x in range(10)])
+
+"""Python一行代码实现九九乘法表"""
+print('\n'.join('   '.join(['%sX%s=%-2s' % (y, x, x * y) for y in range(1, x + 1)]) for x in range(1, 10)))
+
+"""[0~10]以索引分别打印奇偶数列表"""
+a = [i for i in range(10)]
+print(f"原数列：{a}\n偶数列：{a[::2]}\n奇数列：{a[1::2]}")
+
+"""一行打印[[1, 2, 3]...[100, 101, 102]]"""
+print([[x for x in range(1, 103)][i:i + 3] for i in range(0, 102, 3)])
+
+# 二维列表转置
+"""[[1, 2, 3], [4, 5, 6], [7, 8, 9]] >> [[1, 4, 7], [2, 5, 8], [3, 6, 9]]"""
+a_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
+t = [i for i in a_list]
+print([[i[j] for i in a_list] for j in range(len(a_list[0]))])
+
+"""[1, 7, 19...28519, 29107, 29701]"""
+list3 = [x**3 - (x-1)**3 for x in range(1, 101)]
+print(list3)
+
+import random
+import cProfile
+
+
+def f1(lIn):
+    l1 = sorted(lIn)
+    l2 = [i for i in l1 if i< 0.5]
+    return [i * i for i in l2]
+
+
+def f2(lIn):
+    l1 = [i for i in lIn if i < 0.5]
+    l2 = sorted(l1)
+    return [i * i for i in l2]
+
+
+def f3(lIn):
+    l1 = [i * i for i in lIn]
+    l2 = sorted(l1)
+    return [i for i in l1 if i < (0.5 * 0.5)]
+
+
+lIn = [random.random() for i in range(100000)]
+cProfile.run('f1(lIn)')
+cProfile.run('f2(lIn)')
+cProfile.run('f3(lIn)')
+
+
+def a():
+    alist = []
+    for i in range(1, 100):
+        if i % 6 == 0:
+            alist.append(i)
+    last_num = alist[-3:]
+    return last_num
+
+
+result = a()
+print(result)
+
Index: PythonCode/FunctoolsLambda/TheFunctools/FunctoolsFilter.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/FunctoolsLambda/TheFunctools/FunctoolsFilter.py	(date 1591893393988)
+++ PythonCode/FunctoolsLambda/TheFunctools/FunctoolsFilter.py	(date 1591893393988)
@@ -0,0 +1,39 @@
+# encoding:utf-8
+
+a = [1, 2, 3, 4, 5, 6, 7]
+b = filter(lambda x: x > 5, a)
+for i in b:
+    print(i)
+a = map(lambda x: x * 2, [1, 2, 3])
+
+print(a)
+print(list(a))
+
+# [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
+nums = range(2, 20)
+for i in nums:
+    nums = filter(lambda x: x == i or x % i, nums)
+print(list(nums))
+# >> [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
+
+
+my_list = ['edward', 'Smith', 'Obama', 'john', 'tom']
+
+
+def f(x):
+    return x[0].isupper()
+
+
+result = filter(f, my_list)
+print(list(result))
+
+# ---
+my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
+
+
+def f(x):
+    return x % 2 == 0
+
+
+result = filter(f, my_list)
+print(list(result))
Index: PythonCode/FunctoolsLambda/TheFunctools/FunctoolsMap.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/FunctoolsLambda/TheFunctools/FunctoolsMap.py	(date 1592366172017)
+++ PythonCode/FunctoolsLambda/TheFunctools/FunctoolsMap.py	(date 1592366172017)
@@ -0,0 +1,39 @@
+# encoding:utf-8
+
+my_list = [1, 2, 3, 4, 5]
+
+
+def f(x):
+    return x ** 2
+
+
+result = map(f, my_list)
+print(type(result), result, list(result))
+
+
+# ---
+
+my_list = ['smith', 'edward', 'john', 'obama', 'tom']
+
+
+def f(x):
+    return x[0].upper() + x[1:]
+
+
+result = map(f, my_list)
+print(list(result))
+
+import numpy
+
+print(list(map(lambda x , y: x + y, range(20), range(10))))
+print([x + y for x, y in zip(range(20), range(10))])
+print(list(numpy.array(range(10)) + numpy.array(range(10))))
+
+v1 = [21, 34, 45]
+
+v2 = [55, 25, 77]
+
+v = list(map(lambda x: x[0]-x[1], zip(v2, v1)))
+
+print(v)
+
Index: PythonCode/FunctoolsLambda/TheFunctools/FunctoolsReduce.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/FunctoolsLambda/TheFunctools/FunctoolsReduce.py	(date 1591870197636)
+++ PythonCode/FunctoolsLambda/TheFunctools/FunctoolsReduce.py	(date 1591870197636)
@@ -0,0 +1,59 @@
+# encoding:utf-8
+
+import functools
+
+lista = [1, 2, 3, 4, 5, 6, 7]
+result = functools.reduce(lambda i, j: i + j, lista)
+print(result)
+
+# ---
+list2 = []
+list2.append(functools.reduce(lambda i, j: j**3 - i**3, range(2)))
+print(list2)
+
+
+def Sum(*args):
+    count = 0
+    for i in args:
+        count += i
+    return count
+
+
+def main():
+    sum = 0  # 定义变量做累加器
+    n = int(input('n='))  # 从键盘上输入累加的范围
+    for x in range(n):
+        sum += (x + 1)
+    print(sum)
+
+
+def sum_numbers(num):
+    # 1.出口
+    if num == 1:
+        return 1
+
+    # 2.数组累加
+    temp = sum_numbers(num - 1)
+    print(temp)
+    print(num)
+    return num + temp
+
+
+result = sum_numbers(3)
+print(result)
+
+
+if __name__ == '__main__':
+    main()
+
+# ---
+
+my_list = [1, 2, 3, 4, 5]
+
+
+def f(x1, x2):
+    return x1 + x2
+
+
+result = functools.reduce(f, my_list)
+print(result)
Index: PythonCode/InterviewQuestions/股票Max利润.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/InterviewQuestions/股票Max利润.py	(date 1584440892354)
+++ PythonCode/InterviewQuestions/股票Max利润.py	(date 1584440892354)
@@ -0,0 +1,48 @@
+"""
+刷题34——面试题63：股票的最大利润
+
+题目：
+假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？
+例如，一只股票在某些时间节点的价格位{9, 11, 8, 5, 7, 12, 16, 14}。如果我们能在价格为5
+的时候买入并在价格为16时卖出，则能收获最大的利润11。
+
+思路：
+股票交易的利润来自股票买入和卖出价格的差价。当然，我们只能在买入某只股票之后才能卖出。
+如果把股票的买入价和卖出价两个数字组成一个数对，那么利润就是这个数对的差值。因此，
+最大的利润就是数组中所有数对的最大差值。
+
+我们定义函数diff(i)为当卖出价为数组中第i个数字时可能获得的最大利润。显然，
+当卖出价固定时，买入价越低获得的利润越大。也就是说，如果在扫描到数组中的第i个数字时，
+只要我们能记住之前的i-1个数字中的最小值，就能算出在当前价位卖出时可能得到的最大利润。
+
+综上，python代码如下：
+"""
+
+# 解法一
+# class Solution:
+#     def maxProfit(self, prices: List[int]) -> int:
+#         f = [0]
+#         for i in range(1, len(prices)):
+#             f.append(max(0, f[i-1]+prices[i]-prices[i-1]))
+#         return max(f)
+
+
+# 解法二（推荐）
+def MaxDiff(nums):
+    if not nums:
+        return 0
+    n = len(nums)
+    min_value = nums[0]
+    maxDiff = nums[1] - min_value
+    for i in range(2, n):
+        if nums[i - 1] < min_value:
+            min_value = nums[i - 1]
+        currentDiff = nums[i] - min_value
+        if currentDiff > maxDiff:
+            maxDiff = currentDiff
+
+    return maxDiff
+
+
+# select scode from excel where object = yuwen order_by Scode desc limit 2, 1;
+
Index: PythonCode/InterviewQuestions/chaojiying/crack_click.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/InterviewQuestions/chaojiying/crack_click.py	(date 1581751629920)
+++ PythonCode/InterviewQuestions/chaojiying/crack_click.py	(date 1581751629920)
@@ -0,0 +1,171 @@
+import time
+from io import BytesIO
+from PIL import Image
+from selenium import webdriver
+from selenium.webdriver import ActionChains
+from selenium.webdriver.common.by import By
+from selenium.webdriver.support.ui import WebDriverWait
+from selenium.webdriver.support import expected_conditions as EC
+from chaojiying import Chaojiying
+
+# 需要登陆的账号密码
+EMAIL = ''
+PASSWORD = ''
+
+# 超级鹰账号密码
+CHAOJIYING_USERNAME = ''
+CHAOJIYING_PASSWORD = ''
+# 应用id 超级鹰创建应用
+CHAOJIYING_SOFT_ID = 895816
+# 验证类型 建议四字 成功率高
+CHAOJIYING_KIND = 9201
+
+
+class CrackTouClick():
+    def __init__(self):
+        # 登陆地址
+        self.url = 'https://login.flyme.cn/'
+        self.browser = webdriver.Chrome('/Users/7z1/chromedriver')
+        self.wait = WebDriverWait(self.browser, 20)
+        self.email = EMAIL
+        self.password = PASSWORD
+        self.chaojiying = Chaojiying(CHAOJIYING_USERNAME, CHAOJIYING_PASSWORD, CHAOJIYING_SOFT_ID)
+    
+    def __del__(self):
+        self.browser.close()
+    
+    def open(self):
+        """
+        打开网页输入用户名密码
+        :return: None
+        """
+        self.browser.get(self.url)
+        email = self.wait.until(EC.presence_of_element_located((By.ID, 'account')))
+        password = self.wait.until(EC.presence_of_element_located((By.ID, 'password')))
+        email.send_keys(self.email)
+        password.send_keys(self.password)
+    
+    def get_touclick_button(self):
+        """
+        获取初始验证按钮
+        :return:
+        """
+        button = self.wait.until(EC.element_to_be_clickable((By.CLASS_NAME, 'geetest_radar_tip')))
+        return button
+    
+    def get_touclick_element(self):
+        """
+        获取验证图片对象
+        :return: 图片对象
+        """
+        element = self.wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'geetest_item_img')))
+        return element
+    
+    def get_position(self):
+        """
+        获取验证码位置
+        :return: 验证码位置元组
+        """
+        element = self.get_touclick_element()
+        time.sleep(10)
+        location = element.location
+        size = element.size
+        top, bottom, left, right = location['y'], location['y'] + size['height'], location['x'], location['x'] + size[
+            'width']
+        return (top, bottom, left, right)
+    
+    def get_screenshot(self):
+        """
+        获取网页截图
+        :return: 截图对象
+        """
+        screenshot = self.browser.get_screenshot_as_png()
+        screenshot = Image.open(BytesIO(screenshot))
+        return screenshot
+    
+    def get_touclick_image(self, name='captcha.png'):
+        """
+        获取验证码图片
+        :return: 图片对象
+        """
+        top, bottom, left, right = self.get_position()
+        print('验证码位置', top, bottom, left, right)
+        screenshot = self.get_screenshot()
+        captcha = screenshot.crop((left, top, right, bottom))
+        captcha.save(name)
+        return captcha
+    
+    def get_points(self, captcha_result):
+        """
+        解析识别结果
+        :param captcha_result: 识别结果
+        :return: 转化后的结果
+        """
+        groups = captcha_result.get('pic_str').split('|')
+        locations = [[int(number) for number in group.split(',')] for group in groups]
+        return locations
+    
+    def touch_click_words(self, locations):
+        """
+        点击验证图片
+        :param locations: 点击位置
+        :return: None
+        """
+        for location in locations:
+            print(location)
+            ActionChains(self.browser).move_to_element_with_offset(self.get_touclick_element(), location[0],
+                                                                   location[1]).click().perform()
+            time.sleep(1)
+    
+    def touch_click_verify(self):
+        """
+        点击验证按钮
+        :return: None
+        """
+        button = self.wait.until(EC.element_to_be_clickable((By.CLASS_NAME, 'geetest_commit_tip')))
+        button.click()
+    
+    def login(self):
+        """
+        登录
+        :return: None
+        """
+        submit = self.wait.until(EC.element_to_be_clickable((By.ID, 'login')))
+        submit.click()
+        time.sleep(10)
+        print('登录成功')
+    
+    def crack(self):
+        """
+        破解入口
+        :return: None
+        """
+        self.open()
+        # 点击验证按钮
+        button = self.get_touclick_button()
+        button.click()
+        # 获取验证码图片
+        image = self.get_touclick_image()
+        bytes_array = BytesIO()
+        image.save(bytes_array, format='PNG')
+        # 识别验证码
+        result = self.chaojiying.post_pic(bytes_array.getvalue(), CHAOJIYING_KIND)
+        print(result)
+        locations = self.get_points(result)
+        self.touch_click_words(locations)
+        self.touch_click_verify()
+        # 判定是否成功
+        success = self.wait.until(
+            EC.text_to_be_present_in_element((By.CLASS_NAME, 'geetest_success_radar_tip'), '验证成功'))
+        print(success)
+        
+        # 失败后重试
+        if not success:
+            self.crack()
+        else:
+            self.login()
+
+
+if __name__ == '__main__':
+    crack = CrackTouClick()
+    crack.crack()
Index: PythonCode/InterviewQuestions/chaojiying/chaojiying.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/InterviewQuestions/chaojiying/chaojiying.py	(date 1581751629488)
+++ PythonCode/InterviewQuestions/chaojiying/chaojiying.py	(date 1581751629488)
@@ -0,0 +1,44 @@
+import requests
+from hashlib import md5
+
+
+class Chaojiying(object):
+
+    def __init__(self, username, password, soft_id):
+        self.username = username
+        self.password = md5(password.encode('utf-8')).hexdigest()
+        self.soft_id = soft_id
+        self.base_params = {
+            'user': self.username,
+            'pass2': self.password,
+            'softid': self.soft_id,
+        }
+        self.headers = {
+            'Connection': 'Keep-Alive',
+            'User-Agent': 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)',
+        }
+        
+
+    def post_pic(self, im, codetype):
+        """
+        im: 图片字节
+        codetype: 题目类型 参考 http://www.chaojiying.com/price.html
+        """
+        params = {
+            'codetype': codetype,
+        }
+        params.update(self.base_params)
+        files = {'userfile': ('ccc.jpg', im)}
+        r = requests.post('http://upload.chaojiying.net/Upload/Processing.php', data=params, files=files, headers=self.headers)
+        return r.json()
+
+    def report_error(self, im_id):
+        """
+        im_id:报错题目的图片ID
+        """
+        params = {
+            'id': im_id,
+        }
+        params.update(self.base_params)
+        r = requests.post('http://upload.chaojiying.net/Upload/ReportError.php', data=params, headers=self.headers)
+        return r.json()
Index: PythonCode/MultitaskProgramming/TheThread/TheThread.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/MultitaskProgramming/TheThread/TheThread.py	(date 1591866946553)
+++ PythonCode/MultitaskProgramming/TheThread/TheThread.py	(date 1591866946553)
@@ -0,0 +1,197 @@
+# -*- coding:utf-8 -*-
+
+import threading
+
+"""线程"""
+
+# 用两个线程，交替打印奇数和偶数(1-100)
+# 第一个线程，打印奇数
+
+
+def threada():
+    for i in range(1, 101):
+        if i % 2 != 0:
+            lockb.acquire()
+            print(i)
+            locka.release()
+            time.sleep(0.2)
+
+
+# 第二个线程，打印偶数
+def threaddb():
+    for i in range(1, 101):
+        if i % 2 == 0:
+            locka.acquire()
+            print(i)
+            lockb.release()
+            time.sleep(0.2)
+
+
+if __name__ == "__main__":
+    locka = threading.Lock()
+    lockb = threading.Lock()
+    ta = threading.Thread(None, threada)
+    tb = threading.Thread(None, threaddb)
+    locka.acquire()  # 保证a先执行
+    ta.start()
+    tb.start()
+    ta.join()
+
+# python多线程
+# ! /usr/bin/evn python3
+# --*-- coding: utf-8 --*--
+
+# 该实例反编译来说明函数执行流程
+import dis
+
+
+def add(a):
+    a = a + 1
+    return a
+
+
+print(dis.dis(add))
+
+# Python中一个线程对应于C语言中的一个线程（CPython而言）（Python并不一定就慢，视情况而定）
+# pypy解释器专门克服gil慢的一种解释器（去gil化）
+# GIL使用同一个时刻只有一个线程在一个cpu上执行字节码，无法将多个线程映射到多个CPU上
+# gil锁会根据执行的字节码或时间片划分适当的释放（python内部实现机制）
+# 该实例来说明GIL在某种情况下会自动释放让下一个线程去执行（时间片来回切换）
+
+# 反编译（函数执行流程）同一时刻只有一个线程在CPU上执行
+total = 0
+
+
+def add():
+    global total
+    for i in range(1000000):
+        total += 1
+
+
+def desc():
+    global total
+    for j in range(1000000):
+        total -= 1
+
+
+import threading
+
+threading1 = threading.Thread(target=add)
+threading2 = threading.Thread(target=desc)
+
+threading1.start()
+threading2.start()
+
+threading1.join()
+threading2.join()
+print(total)
+
+# 对于io操作来说，多线程和多进程差别不大（用两种方法实现Python多线程编写）
+# 1、通过Thread类实例化(适用简单的或是线程池)
+
+# 以模拟简单的爬取文章列表页在获取详情页作一示例
+import time
+import threading
+
+
+def get_detail_html(url):
+    # 爬取文章详情页
+    print("get detail html started")
+    time.sleep(2)
+    print("get detail html end")
+
+
+def get_detail_url(url):
+    # 爬取文章列表页
+    print("get url started")
+    time.sleep(4)
+    print("get detail url end")
+
+
+if __name__ == "__main__":
+    thread1 = threading.Thread(target=get_detail_html, args=("",))  # 线程1
+    thread2 = threading.Thread(target=get_detail_url, args=("",))  # 线程2
+    # thread1.setDaemon(True) #守护线程
+    # thread2.setDaemon(True) #守护线程
+    start_time = time.time()
+    thread1.start()
+    thread2.start()
+    # thread1.join() #阻塞等待
+    # thread2.join() #阻塞等待
+    print("last time: {}".format(time.time() - start_time))  # 主线程
+
+# 2、通过集成Thread来实现多线程
+import threading
+import time
+
+
+class GetDetailHtml(threading.Thread):
+    def __init__(self, name):  # 重写__init__方法
+        super().__init__(name=name)  # 调用__init__方法
+
+    def run(self):  # 重写run方法,而非start方法
+        print("get detail html")
+        time.sleep(2)
+        print("get html end")
+
+
+class GetDetailUrl(threading.Thread):
+    def __init__(self, name):  # 重写__init__方法
+        super().__init__(name=name)  # 调用__init__方法
+
+    def run(self):  # 重写run方法，而非start方法(在此可以编写逻辑复杂的程序)
+        print("get detail url")
+        time.sleep(4)
+        print("get url end")
+
+
+if __name__ == "__main__":
+    thread1 = GetDetailHtml("get_detail_html")
+    thread2 = GetDetailUrl("get_detail_url")
+    start_time = time.time()
+    thread1.start()
+    thread2.start()
+    thread1.join()  # 阻塞等待回收
+    thread2.join()  ##阻塞等待回收
+    # 当主线程退出的时候，子线程kill掉
+    print("last time: {}".format(time.time() - start_time))
+
+# 线程通信
+from queue import Queue  # 线程通信=====(队列)
+
+
+# 通过queue
+
+
+def get_detail_html(queue):
+    while True:
+        queue.put()
+        print("get detail html started")
+        time.sleep(3)
+        print("get detail html end")
+
+
+def get_detail_url(queue):
+    while True:
+        print("get detail url started")
+        queue.get(1)
+        time.sleep(1)
+        print("get detail url end")
+
+
+if __name__ == "__main__":
+    url_queue = Queue(maxsize=1000)
+    thread2 = threading.Thread(target=get_detail_url, args=(url_queue,))
+    thread2.start()
+    for i in range(2):
+        thread1 = threading.Thread(target=get_detail_html, args=(url_queue,))
+        thread1.start()
+        # thread1.join()
+    # thread1.setDaemon(True)
+    # thread2.setDaemon(True)
+    start_time = time.time()
+
+    # thread2.join()
+    print(time.time() - start_time)
+
+
Index: PythonCode/MultitaskProgramming/TheThread/TheMultithreading.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/MultitaskProgramming/TheThread/TheMultithreading.py	(date 1591890001252)
+++ PythonCode/MultitaskProgramming/TheThread/TheMultithreading.py	(date 1591890001252)
@@ -0,0 +1,412 @@
+# ! /usr/bin/evn python3
+# --*-- coding: utf-8 --*--
+
+# 1. python多线程
+
+# 该实例反编译来说明函数执行流程
+import dis
+
+
+def add(a):
+    a = a + 1
+    return a
+
+
+print(dis.dis(add))
+
+# Python中一个线程对应于C语言中的一个线程（CPython而言）（Python并不一定就慢，视情况而定）
+# pypy解释器专门克服gil慢的一种解释器（去gil化）
+# GIL使用同一个时刻只有一个线程在一个cpu上执行字节码，无法将多个线程映射到多个CPU上
+# gil锁会根据执行的字节码或时间片划分适当的释放（python内部实现机制）
+# 该实例来说明GIL在某种情况下会自动释放让下一个线程去执行（时间片来回切换）
+
+# 反编译（函数执行流程）同一时刻只有一个线程在CPU上执行
+total = 0
+
+
+def add():
+    global total
+    for i in range(1000000):
+        total += 1
+
+
+def desc():
+    global total
+    for j in range(1000000):
+        total -= 1
+
+
+import threading
+
+threading1 = threading.Thread(target=add)
+threading2 = threading.Thread(target=desc)
+
+threading1.start()
+threading2.start()
+
+threading1.join()
+threading2.join()
+print(total)
+
+# 对于io操作来说，多线程和多进程差别不大（用两种方法实现Python多线程编写）
+# 1、通过Thread类实例化(适用简单的或是线程池)
+
+# 以模拟简单的爬取文章列表页在获取详情页作一示例
+import time
+import threading
+
+
+def get_detail_html(url):
+    # 爬取文章详情页
+    print("get detail html started")
+    time.sleep(2)
+    print("get detail html end")
+
+
+def get_detail_url(url):
+    # 爬取文章列表页
+    print("get url started")
+    time.sleep(4)
+    print("get detail url end")
+
+
+if __name__ == "__main__":
+    thread1 = threading.Thread(target=get_detail_html, args=("",))  # 线程1
+    thread2 = threading.Thread(target=get_detail_url, args=("",))  # 线程2
+    # thread1.setDaemon(True) #守护线程
+    # thread2.setDaemon(True) #守护线程
+    start_time = time.time()
+    thread1.start()
+    thread2.start()
+    # thread1.join() #阻塞等待
+    # thread2.join() #阻塞等待
+    print("last time: {}".format(time.time() - start_time))  # 主线程
+
+# 2、通过集成Thread来实现多线程
+import threading
+import time
+
+
+class GetDetailHtml(threading.Thread):
+    def __init__(self, name):  # 重写__init__方法
+        super().__init__(name=name)  # 调用__init__方法
+
+    def run(self):  # 重写run方法,而非start方法
+        print("get detail html")
+        time.sleep(2)
+        print("get html end")
+
+
+class GetDetailUrl(threading.Thread):
+    def __init__(self, name):  # 重写__init__方法
+        super().__init__(name=name)  # 调用__init__方法
+
+    def run(self):  # 重写run方法，而非start方法(在此可以编写逻辑复杂的程序)
+        print("get detail url")
+        time.sleep(4)
+        print("get url end")
+
+
+if __name__ == "__main__":
+    thread1 = GetDetailHtml("get_detail_html")
+    thread2 = GetDetailUrl("get_detail_url")
+    start_time = time.time()
+    thread1.start()
+    thread2.start()
+    thread1.join()  # 阻塞等待回收
+    thread2.join()  ##阻塞等待回收
+    # 当主线程退出的时候，子线程kill掉
+    print("last time: {}".format(time.time() - start_time))
+
+
+# python多线程详解
+import threading
+from threading import Lock,Thread
+import time, os
+
+
+'''
+                                      python多线程详解
+      什么是线程？
+      线程也叫轻量级进程，是操作系统能够进行运算调度的最小单位，它被包涵在进程之中，是进程中的实际运作单位。
+      线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所
+      拥有的全部资源。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行
+'''
+
+'''
+    为什么要使用多线程？
+    线程在程序中是独立的、并发的执行流。与分隔的进程相比，进程中线程之间的隔离程度要小，它们共享内存、文件句柄
+    和其他进程应有的状态。
+    因为线程的划分尺度小于进程，使得多线程程序的并发性高。进程在执行过程之中拥有独立的内存单元，而多个线程共享
+    内存，从而极大的提升了程序的运行效率。
+    线程比进程具有更高的性能，这是由于同一个进程中的线程都有共性，多个线程共享一个进程的虚拟空间。线程的共享环境
+    包括进程代码段、进程的共有数据等，利用这些共享的数据，线程之间很容易实现通信。
+    操作系统在创建进程时，必须为改进程分配独立的内存空间，并分配大量的相关资源，但创建线程则简单得多。因此，使用多线程
+    来实现并发比使用多进程的性能高得要多。
+'''
+
+'''
+    总结起来，使用多线程编程具有如下几个优点：
+    进程之间不能共享内存，但线程之间共享内存非常容易。
+    操作系统在创建进程时，需要为该进程重新分配系统资源，但创建线程的代价则小得多。因此使用多线程来实现多任务并发执行比使用多进程的效率高
+    python语言内置了多线程功能支持，而不是单纯地作为底层操作系统的调度方式，从而简化了python的多线程编程。
+'''
+
+
+'''
+    普通创建方式
+'''
+# def run(n):
+#     print('task',n)
+#     time.sleep(1)
+#     print('2s')
+#     time.sleep(1)
+#     print('1s')
+#     time.sleep(1)
+#     print('0s')
+#     time.sleep(1)
+#
+# if __name__ == '__main__':
+#     t1 = threading.Thread(target=run,args=('t1',))     # target是要执行的函数名（不是函数），args是函数对应的参数，以元组的形式存在
+#     t2 = threading.Thread(target=run,args=('t2',))
+#     t1.start()
+#     t2.start()
+
+
+'''
+    自定义线程：继承threading.Thread来定义线程类，其本质是重构Thread类中的run方法
+'''
+# class MyThread(threading.Thread):
+#     def __init__(self,n):
+#         super(MyThread,self).__init__()   #重构run函数必须写
+#         self.n = n
+#
+#     def run(self):
+#         print('task',self.n)
+#         time.sleep(1)
+#         print('2s')
+#         time.sleep(1)
+#         print('1s')
+#         time.sleep(1)
+#         print('0s')
+#         time.sleep(1)
+#
+# if __name__ == '__main__':
+#     t1 = MyThread('t1')
+#     t2 = MyThread('t2')
+#     t1.start()
+#     t2.start()
+
+
+'''
+    守护线程
+    下面这个例子，这里使用setDaemon(True)把所有的子线程都变成了主线程的守护线程，
+    因此当主线程结束后，子线程也会随之结束，所以当主线程结束后，整个程序就退出了。
+    所谓’线程守护’，就是主线程不管该线程的执行情况，只要是其他子线程结束且主线程执行完毕，主线程都会关闭。也就是说:主线程不等待该守护线程的执行完再去关闭。
+'''
+# def run(n):
+#     print('task',n)
+#     time.sleep(1)
+#     print('3s')
+#     time.sleep(1)
+#     print('2s')
+#     time.sleep(1)
+#     print('1s')
+#
+# if __name__ == '__main__':
+#     t=threading.Thread(target=run,args=('t1',))
+#     t.setDaemon(True)
+#     t.start()
+#     print('end')
+'''
+    通过执行结果可以看出，设置守护线程之后，当主线程结束时，子线程也将立即结束，不再执行
+'''
+
+'''
+    主线程等待子线程结束
+    为了让守护线程执行结束之后，主线程再结束，我们可以使用join方法，让主线程等待子线程执行
+'''
+# def run(n):
+#     print('task',n)
+#     time.sleep(2)
+#     print('5s')
+#     time.sleep(2)
+#     print('3s')
+#     time.sleep(2)
+#     print('1s')
+# if __name__ == '__main__':
+#     t=threading.Thread(target=run,args=('t1',))
+#     t.setDaemon(True)    #把子线程设置为守护线程，必须在start()之前设置
+#     t.start()
+#     t.join()     #设置主线程等待子线程结束
+#     print('end')
+
+
+'''
+    多线程共享全局变量
+    线程时进程的执行单元，进程时系统分配资源的最小执行单位，所以在同一个进程中的多线程是共享资源的
+'''
+# g_num = 100
+# def work1():
+#     global  g_num
+#     for i in range(3):
+#         g_num+=1
+#     print('in work1 g_num is : %d' % g_num)
+#
+# def work2():
+#     global g_num
+#     print('in work2 g_num is : %d' % g_num)
+#
+# if __name__ == '__main__':
+#     t1 = threading.Thread(target=work1)
+#     t1.start()
+#     time.sleep(1)
+#     t2=threading.Thread(target=work2)
+#     t2.start()
+
+
+'''
+        由于线程之间是进行随机调度，并且每个线程可能只执行n条执行之后，当多个线程同时修改同一条数据时可能会出现脏数据，
+    所以出现了线程锁，即同一时刻允许一个线程执行操作。线程锁用于锁定资源，可以定义多个锁，像下面的代码，当需要独占
+    某一个资源时，任何一个锁都可以锁定这个资源，就好比你用不同的锁都可以把这个相同的门锁住一样。
+        由于线程之间是进行随机调度的，如果有多个线程同时操作一个对象，如果没有很好地保护该对象，会造成程序结果的不可预期，
+    我们因此也称为“线程不安全”。
+        为了防止上面情况的发生，就出现了互斥锁（Lock）
+'''
+# def work():
+#     global n
+#     lock.acquire()
+#     temp = n
+#     time.sleep(0.1)
+#     n = temp-1
+#     lock.release()
+#
+#
+# if __name__ == '__main__':
+#     lock = Lock()
+#     n = 100
+#     l = []
+#     for i in range(100):
+#         p = Thread(target=work)
+#         l.append(p)
+#         p.start()
+#     for p in l:
+#         p.join()
+
+
+'''
+    递归锁：RLcok类的用法和Lock类一模一样，但它支持嵌套，在多个锁没有释放的时候一般会使用RLock类
+'''
+# def func(lock):
+#     global gl_num
+#     lock.acquire()
+#     gl_num += 1
+#     time.sleep(1)
+#     print(gl_num)
+#     lock.release()
+#
+#
+# if __name__ == '__main__':
+#     gl_num = 0
+#     lock = threading.RLock()
+#     for i in range(10):
+#         t = threading.Thread(target=func,args=(lock,))
+#         t.start()
+
+
+'''
+    信号量（BoundedSemaphore类）
+    互斥锁同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据，比如厕所有3个坑，
+    那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去
+'''
+# def run(n,semaphore):
+#     semaphore.acquire()   #加锁
+#     time.sleep(3)
+#     print('run the thread:%s\n' % n)
+#     semaphore.release()    #释放
+#
+#
+# if __name__== '__main__':
+#     num=0
+#     semaphore = threading.BoundedSemaphore(5)   #最多允许5个线程同时运行
+#     for i in range(22):
+#         t = threading.Thread(target=run,args=('t-%s' % i,semaphore))
+#         t.start()
+#     while threading.active_count() !=1:
+#         pass
+#     else:
+#         print('----------all threads done-----------')
+
+'''
+    python线程的事件用于主线程控制其他线程的执行，事件是一个简单的线程同步对象，其主要提供以下的几个方法：
+        clear将flag设置为 False
+        set将flag设置为 True
+        is_set判断是否设置了flag
+        wait会一直监听flag，如果没有检测到flag就一直处于阻塞状态
+    事件处理的机制：全局定义了一个Flag，当Flag的值为False，那么event.wait()就会阻塞，当flag值为True，
+    那么event.wait()便不再阻塞
+'''
+event = threading.Event()
+def lighter():
+    count = 0
+    event.set()         #初始者为绿灯
+    while True:
+        if 5 < count <=10:
+            event.clear()  #红灯，清除标志位
+            print("\33[41;lmred light is on...\033[0m]")
+        elif count > 10:
+            event.set()    #绿灯，设置标志位
+            count = 0
+        else:
+            print('\33[42;lmgreen light is on...\033[0m')
+
+        time.sleep(1)
+        count += 1
+
+
+def car(name):
+    while True:
+        if event.is_set():     #判断是否设置了标志位
+            print('[%s] running.....'%name)
+            time.sleep(1)
+        else:
+            print('[%s] sees red light,waiting...'%name)
+            event.wait()
+            print('[%s] green light is on,start going...'%name)
+
+
+# startTime = time.time()
+light = threading.Thread(target=lighter,)
+light.start()
+
+car = threading.Thread(target=car,args=('MINT',))
+car.start()
+endTime = time.time()
+# print('用时：',endTime-startTime)
+
+'''
+                           GIL  全局解释器
+        在非python环境中，单核情况下，同时只能有一个任务执行。多核时可以支持多个线程同时执行。但是在python中，无论有多少个核
+        同时只能执行一个线程。究其原因，这就是由于GIL的存在导致的。
+        GIL的全程是全局解释器，来源是python设计之初的考虑，为了数据安全所做的决定。某个线程想要执行，必须先拿到GIL，我们可以
+        把GIL看做是“通行证”，并且在一个python进程之中，GIL只有一个。拿不到线程的通行证，并且在一个python进程中，GIL只有一个，
+        拿不到通行证的线程，就不允许进入CPU执行。GIL只在cpython中才有，因为cpython调用的是c语言的原生线程，所以他不能直接操
+        作cpu，而只能利用GIL保证同一时间只能有一个线程拿到数据。而在pypy和jpython中是没有GIL的
+        python在使用多线程的时候，调用的是c语言的原生过程。
+'''
+'''
+                            python针对不同类型的代码执行效率也是不同的
+        1、CPU密集型代码（各种循环处理、计算等），在这种情况下，由于计算工作多，ticks技术很快就会达到阀值，然后出发GIL的
+        释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对CPU密集型代码并不友好。
+        2、IO密集型代码（文件处理、网络爬虫等设计文件读写操作），多线程能够有效提升效率（单线程下有IO操作会进行IO等待，
+        造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序的执行
+        效率）。所以python的多线程对IO密集型代码比较友好。
+'''
+'''
+    主要要看任务的类型，我们把任务分为I/O密集型和计算密集型，而多线程在切换中又分为I/O切换和时间切换。如果任务属于是I/O密集型，
+    若不采用多线程，我们在进行I/O操作时，势必要等待前面一个I/O任务完成后面的I/O任务才能进行，在这个等待的过程中，CPU处于等待
+    状态，这时如果采用多线程的话，刚好可以切换到进行另一个I/O任务。这样就刚好可以充分利用CPU避免CPU处于闲置状态，提高效率。但是
+    如果多线程任务都是计算型，CPU会一直在进行工作，直到一定的时间后采取多线程时间切换的方式进行切换线程，此时CPU一直处于工作状态，
+    此种情况下并不能提高性能，相反在切换多线程任务时，可能还会造成时间和资源的浪费，导致效能下降。这就是造成上面两种多线程结果不能的解释。
+结论:I/O密集型任务，建议采取多线程，还可以采用多进程+协程的方式(例如:爬虫多采用多线程处理爬取的数据)；对于计算密集型任务，python此时就不适用了。
+'''
Index: PythonCode/MultitaskProgramming/TheProcess/TheProcess.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- PythonCode/MultitaskProgramming/TheProcess/TheProcess.py	(date 1591889479790)
+++ PythonCode/MultitaskProgramming/TheProcess/TheProcess.py	(date 1591889479790)
@@ -0,0 +1,196 @@
+# -*- coding:utf-8 -*-
+
+import os
+import random
+import time
+import threading
+from multiprocessing import Process, Pool, Pipe, Manager, Queue
+
+
+"""进程(Process(([group [, target [, name [, args [, kwargs]]]]])))"""
+
+
+# 给子进程指定函数传递参数 Demo：
+
+
+def pro_func(name, age, **kwargs):
+    for i in range(3):
+        print(f"子进程正在运行中，name={name}, age={age}, pid={os.getpid()}\n{kwargs}")
+        time.sleep(0.2)
+
+
+if __name__ == "__main__":
+    # 创建Process对象
+    p = Process(target=pro_func, args=("龟叔", 18), kwargs={"林纳斯": 20})
+    # 启动进程
+    p.start()
+    time.sleep(0.6)
+    # 0.6秒钟之后，结束子进程
+    p.terminate()
+    p.join()
+
+
+
+import multiprocessing
+# 线程通信=====(队列) ---- from queue import Queue
+# 进程池中进程通信=====(队列) --- from multiprocess.Manager import Queue
+# 多进程通信=========(队列)   ---- from multiprocess import Queue
+import time
+
+
+def after(conn):
+    while True:
+        print("接收到数据:", conn.recv())
+        time.sleep(1)
+
+
+def before(conn):
+    while True:
+        data = [42, None, 34, 'hello']
+        conn.send(data)
+        print("正在发送数据：%s" % (data))
+        time.sleep(1)
+
+
+def main():
+    # send recv
+    before_conn, after_conn = multiprocessing.Pipe()
+
+    p1 = multiprocessing.Process(target=after, args=(after_conn,))
+    p1.start()
+
+    p2 = multiprocessing.Process(target=before, args=(before_conn,))
+    p2.start()
+
+    p1.join()
+    p2.join()
+
+
+if __name__ == '__main__':
+    main()
+
+
+# Manager
+# manager中的一些数据结构，dict使用（类似共享变量）
+
+
+def add_data(p_dict, key, value):
+    p_dict[key] = value
+
+
+if __name__ == "__main__":
+    progress = Manager().dict()
+    first_progress = Process(target=add_data, args=(progress, "a", 1))
+    second_progress = Process(target=add_data, args=(progress, "b", 2))
+    first_progress.start()
+    second_progress.start()
+    first_progress.join()
+    second_progress.join()
+    print(progress)
+
+# # 分布式进程
+# # 遇到大型计算任务，一台主机无法完成时，需要多台主机进行计算
+#
+# # 管理端
+# import random
+# from queue import Queue
+# # BaseManager: 提供了不同机器之间共享数据的一种方法(ip:port)
+# from multiprocessing.managers import BaseManager
+#
+# # 1. 创建存储任务需要的队列
+# task_queue = Queue()
+#
+# # 2. 存储任务执行结果的队列
+# result_queue = Queue()
+#
+# # 3. 将队列注册到网上(使得其他主机也可以访问)
+# BaseManager.register('get_task_queue', callable=lambda: task_queue)
+# BaseManager.register('get_result_queue', callable=lambda: result_queue)
+#
+# # 绑定ip和端口， 并且来个暗号；
+# manager = BaseManager(address=('172.25.60.250', 4000), authkey=b'westos')
+#
+# # 4. 启动manager对象， 开始共享队列
+# manager.start()
+#
+# # 5. 通过网络访问共享的Queue对象;
+# # BaseManager.register会注册一个方法, 当调用方法时， 执行函数lambda : task_queue;
+# task = manager.get(task_queue)  # Bug
+# result = manager.get_result_queue()  # Bug
+#
+# # 6. 往队列里面放执行任务需要的数据;
+# for i in range(1000):
+#     # 模拟有1000个数字；
+#     n = random.randint(1, 100)
+#     task.put(n)
+#     print("任务列表中加入任务: %d" % (n))
+#
+# # 7. 从result队列中读取各个机器中任务执行的结果;
+# for i in range(1000):
+#     res = result.get()
+#     print("队列任务执行的result: %s" % (res))
+#
+# #  8. 关闭manager对象， 取消共享的队列
+# manager.shutdown()
+#
+# # 被管理端1
+# import time
+# from multiprocessing.managers import BaseManager
+#
+# # 1. 连接Master端， 获取共享的队列;ip是master端的ip， port'也是master端manager进程绑定的端口;
+# slave = BaseManager(address=('172.25.60.250', 4000), authkey=b'westos')
+#
+# # 2. 注册队列， 获取共享的队列内容;
+# BaseManager.register('get_task_queue')
+# BaseManager.register('get_result_queue')
+#
+# # 3. 连接master端;
+# slave.connect()
+#
+# # 4. 通过网络访问共享的队列;
+# task = slave.get_task_queue()
+# result = slave.get_result_queue()
+#
+# # 5. 读取管理端共享的任务， 并依次执行;
+# for i in range(500):
+#     n = task.get()
+#     print("slave1 运行任务 %d ** 2: " % (n))
+#     res = "slave1: %d ** 2 = %d" % (n, n ** 2)
+#     time.sleep(1)
+#     # 将任务的运行结果放入队列中;
+#     result.put(res)
+#
+# print("执行结束........")
+#
+# # 被管理端2
+# import time
+# from multiprocessing.managers import BaseManager
+#
+# # 1. 连接Master端， 获取共享的队列;ip是master端的ip， port'也是master端manager进程绑定的端口;
+# slave = BaseManager(address=('172.25.60.250', 4000), authkey=b'westos')
+#
+# # 2. 注册队列， 获取共享的队列内容;
+# BaseManager.register('get_task_queue')
+# BaseManager.register('get_result_queue')
+#
+# # 3. 连接master端;
+# slave.connect()
+#
+# # 4. 通过网络访问共享的队列;
+# task = slave.get_task_queue()
+# result = slave.get_result_queue()
+#
+# # 5. 读取管理端共享的任务， 并依次执行;
+# for i in range(500):
+#     n = task.get()
+#     print("slave2: 运行任务 %d ** 2: " % (n))
+#     res = "slave2: %d ** 2 = %d" % (n, n ** 2)
+#     time.sleep(1)
+#     # 将任务的运行结果放入队列中;
+#     result.put(res)
+#
+# print("执行结束........")
+
+
+
+"""协程"""
diff --git PythonCode/MultitaskProgramming/TheCoroutines/TheCoroutines_yield.py PythonCode/MultitaskProgramming/TheCoroutines/TheCoroutines_yield.py
new file mode 100644
diff --git PythonCode/MultitaskProgramming/TheCoroutines/__init__.py PythonCode/MultitaskProgramming/TheCoroutines/__init__.py
new file mode 100644
diff --git PythonCode/MultitaskProgramming/TheCoroutines/TheGenerator.py PythonCode/MultitaskProgramming/TheCoroutines/TheGenerator.py
new file mode 100644
diff --git PythonCode/MultitaskProgramming/TheCoroutines/TheIterator.py PythonCode/MultitaskProgramming/TheCoroutines/TheIterator.py
new file mode 100644
diff --git PythonCode/DataStructureAlgorithm/__init__.py PythonCode/DataStructureAlgorithm/__init__.py
new file mode 100644
diff --git PythonCode/DataStructureAlgorithm/Stack/__init__.py PythonCode/DataStructureAlgorithm/Stack/__init__.py
new file mode 100644
diff --git PythonCode/DataStructureAlgorithm/LinkList/__init__.py PythonCode/DataStructureAlgorithm/LinkList/__init__.py
new file mode 100644
diff --git PythonCode/DataStructureAlgorithm/Algorithm/RadixSort.py PythonCode/DataStructureAlgorithm/Algorithm/RadixSort.py
new file mode 100644
diff --git PythonCode/DataStructureAlgorithm/Algorithm/CountSort.py PythonCode/DataStructureAlgorithm/Algorithm/CountSort.py
new file mode 100644
diff --git PythonCode/DataStructureAlgorithm/Algorithm/__init__.py PythonCode/DataStructureAlgorithm/Algorithm/__init__.py
new file mode 100644
diff --git PythonCode/DataStructureAlgorithm/Algorithm/BucketSort.py PythonCode/DataStructureAlgorithm/Algorithm/BucketSort.py
new file mode 100644
diff --git PythonCode/DataStructureAlgorithm/Algorithm/HeapSort.py PythonCode/DataStructureAlgorithm/Algorithm/HeapSort.py
new file mode 100644
diff --git PythonCode/DataStructureAlgorithm/SingLeton/__init__.py PythonCode/DataStructureAlgorithm/SingLeton/__init__.py
new file mode 100644
diff --git PythonCode/DataStructureAlgorithm/QueueDeque/__init__.py PythonCode/DataStructureAlgorithm/QueueDeque/__init__.py
new file mode 100644
diff --git PythonCode/DataStructureAlgorithm/BinarySearchTree/__init__.py PythonCode/DataStructureAlgorithm/BinarySearchTree/__init__.py
new file mode 100644
diff --git PythonCode/DataStructureAlgorithm/TimeSpaceComplexity/__init__.py PythonCode/DataStructureAlgorithm/TimeSpaceComplexity/__init__.py
new file mode 100644
diff --git PythonCode/DecoratorGeneratorIterator/__init__.py PythonCode/DecoratorGeneratorIterator/__init__.py
new file mode 100644
diff --git PythonCode/DecoratorGeneratorIterator/Decorator/__init__.py PythonCode/DecoratorGeneratorIterator/Decorator/__init__.py
new file mode 100644
diff --git PythonCode/DecoratorGeneratorIterator/TheIterator/__init__.py PythonCode/DecoratorGeneratorIterator/TheIterator/__init__.py
new file mode 100644
diff --git PythonCode/DecoratorGeneratorIterator/TheIterator/TheIterator.py PythonCode/DecoratorGeneratorIterator/TheIterator/TheIterator.py
new file mode 100644
diff --git PythonCode/DecoratorGeneratorIterator/TheGenerator/__init__.py PythonCode/DecoratorGeneratorIterator/TheGenerator/__init__.py
new file mode 100644
diff --git PythonCode/Basis/类/多态/多态.py PythonCode/Basis/类/多态/多态.py
new file mode 100644
diff --git PythonCode/Basis/类/多态/__init__.py PythonCode/Basis/类/多态/__init__.py
new file mode 100644
diff --git PythonCode/Basis/类/继承/单继承.py PythonCode/Basis/类/继承/单继承.py
new file mode 100644
diff --git PythonCode/Basis/类/继承/__init__.py PythonCode/Basis/类/继承/__init__.py
new file mode 100644
diff --git PythonCode/Basis/类/继承/多继承.py PythonCode/Basis/类/继承/多继承.py
new file mode 100644
diff --git PythonCode/Basis/类/继承/多层继承.py PythonCode/Basis/类/继承/多层继承.py
new file mode 100644
diff --git PythonCode/Basis/类/魔法方法/__init__.py PythonCode/Basis/类/魔法方法/__init__.py
new file mode 100644
diff --git PythonCode/Basis/类/面向对象/__init__.py PythonCode/Basis/类/面向对象/__init__.py
new file mode 100644
diff --git PythonCode/Basis/类/私有属性(方法)/__init__.py PythonCode/Basis/类/私有属性(方法)/__init__.py
new file mode 100644
diff --git PythonCode/Basis/类/魔法方法/魔法方法.py PythonCode/Basis/类/魔法方法/魔法方法.py
new file mode 100644
diff --git PythonCode/Basis/类/私有属性(方法)/私有方法.py PythonCode/Basis/类/私有属性(方法)/私有方法.py
new file mode 100644
diff --git PythonCode/Basis/类/私有属性(方法)/私有属性.py PythonCode/Basis/类/私有属性(方法)/私有属性.py
new file mode 100644
diff --git PythonCode/Basis/类/类属性&实例属性/类属性.py PythonCode/Basis/类/类属性&实例属性/类属性.py
new file mode 100644
diff --git PythonCode/Basis/类/类属性&实例属性/__init__.py PythonCode/Basis/类/类属性&实例属性/__init__.py
new file mode 100644
diff --git PythonCode/Basis/类/静态方法&类方法/__init__.py PythonCode/Basis/类/静态方法&类方法/__init__.py
new file mode 100644
diff --git PythonCode/Basis/类/类属性&实例属性/实例属性.py PythonCode/Basis/类/类属性&实例属性/实例属性.py
new file mode 100644
diff --git PythonCode/Basis/类/静态方法&类方法/类方法.py PythonCode/Basis/类/静态方法&类方法/类方法.py
new file mode 100644
diff --git PythonCode/Basis/类/静态方法&类方法/静态方法.py PythonCode/Basis/类/静态方法&类方法/静态方法.py
new file mode 100644
diff --git PythonCode/Basis/数学计算/简单计算/__init__.py PythonCode/Basis/数学计算/简单计算/__init__.py
new file mode 100644
diff --git PythonCode/Basis/数学计算/函数/__init__.py PythonCode/Basis/数学计算/函数/__init__.py
new file mode 100644
diff --git PythonCode/Basis/AbnormalMoudle/Moudle/__init__.py PythonCode/Basis/AbnormalMoudle/Moudle/__init__.py
new file mode 100644
diff --git PythonCode/Basis/AbnormalMoudle/Abnormal/自定义异常.py PythonCode/Basis/AbnormalMoudle/Abnormal/自定义异常.py
new file mode 100644
diff --git PythonCode/Basis/AbnormalMoudle/Abnormal/__init__.py PythonCode/Basis/AbnormalMoudle/Abnormal/__init__.py
new file mode 100644
diff --git PythonCode/MultitaskProgramming/TheThread/锁/__init__.py PythonCode/MultitaskProgramming/TheThread/锁/__init__.py
new file mode 100644
diff --git PythonCode/Basis/AbnormalMoudle/Abnormal/异常.py PythonCode/Basis/AbnormalMoudle/Abnormal/异常.py
new file mode 100644
diff --git PythonCode/MultitaskProgramming/TheThread/锁/互斥锁.py PythonCode/MultitaskProgramming/TheThread/锁/互斥锁.py
new file mode 100644
diff --git PythonCode/MultitaskProgramming/TheProcess/InterprocessCommunication/__init__.py PythonCode/MultitaskProgramming/TheProcess/InterprocessCommunication/__init__.py
new file mode 100644
diff --git PythonCode/MultitaskProgramming/TheThread/ThreadsCommunication/__init__.py PythonCode/MultitaskProgramming/TheThread/ThreadsCommunication/__init__.py
new file mode 100644
diff --git PythonCode/Re/__init__.py PythonCode/Re/__init__.py
new file mode 100644
diff --git PythonCode/Basis/__init__.py PythonCode/Basis/__init__.py
new file mode 100644
diff --git PythonCode/Basis/类/__init__.py PythonCode/Basis/类/__init__.py
new file mode 100644
diff --git PythonCode/Basis/变量/__init__.py PythonCode/Basis/变量/__init__.py
new file mode 100644
diff --git PythonCode/Basis/拷贝/__init__.py PythonCode/Basis/拷贝/__init__.py
new file mode 100644
diff --git PythonCode/Basis/数学计算/__init__.py PythonCode/Basis/数学计算/__init__.py
new file mode 100644
diff --git PythonCode/Basis/文件的操作/__init__.py PythonCode/Basis/文件的操作/__init__.py
new file mode 100644
diff --git PythonCode/Basis/文件的操作/文件的备份.py PythonCode/Basis/文件的操作/文件的备份.py
new file mode 100644
diff --git PythonCode/Basis/文件的操作/批量修改文件名.py PythonCode/Basis/文件的操作/批量修改文件名.py
new file mode 100644
diff --git PythonCode/Basis/文件的操作/文件(夹)的相关操作.py PythonCode/Basis/文件的操作/文件(夹)的相关操作.py
new file mode 100644
diff --git PythonCode/Basis/Function_Def/__init__.py PythonCode/Basis/Function_Def/__init__.py
new file mode 100644
diff --git PythonCode/Basis/AbnormalMoudle/__init__.py PythonCode/Basis/AbnormalMoudle/__init__.py
new file mode 100644
diff --git PythonCode/Django/__init__.py PythonCode/Django/__init__.py
new file mode 100644
diff --git PythonCode/Django/视图/__init__.py PythonCode/Django/视图/__init__.py
new file mode 100644
diff --git PythonCode/Django/DjangoRESTframework/__init__.py PythonCode/Django/DjangoRESTframework/__init__.py
new file mode 100644
diff --git PythonCode/Django/DjangoRESTframework/BookInfoSerializer.py PythonCode/Django/DjangoRESTframework/BookInfoSerializer.py
new file mode 100644
diff --git PythonCode/miniWeb/__init__.py PythonCode/miniWeb/__init__.py
new file mode 100644
diff --git PythonCode/Container/__init__.py PythonCode/Container/__init__.py
new file mode 100644
diff --git PythonCode/Container/Str/__init__.py PythonCode/Container/Str/__init__.py
new file mode 100644
diff --git PythonCode/Container/Dict/__init__.py PythonCode/Container/Dict/__init__.py
new file mode 100644
diff --git PythonCode/Container/List/__init__.py PythonCode/Container/List/__init__.py
new file mode 100644
diff --git PythonCode/Container/Tuple/__init__.py PythonCode/Container/Tuple/__init__.py
new file mode 100644
diff --git PythonCode/Container/Tuple/Tuple.py PythonCode/Container/Tuple/Tuple.py
new file mode 100644
diff --git PythonCode/Web_YunWei/__init__.py PythonCode/Web_YunWei/__init__.py
new file mode 100644
diff --git PythonCode/Def_Function/__init__.py PythonCode/Def_Function/__init__.py
new file mode 100644
diff --git PythonCode/JavaScriptCode/__init__.py PythonCode/JavaScriptCode/__init__.py
new file mode 100644
diff --git PythonCode/JavaScriptCode/earth.js PythonCode/JavaScriptCode/earth.js
new file mode 100644
diff --git PythonCode/FunctoolsLambda/__init__.py PythonCode/FunctoolsLambda/__init__.py
new file mode 100644
diff --git PythonCode/FunctoolsLambda/Set/__init__.py PythonCode/FunctoolsLambda/Set/__init__.py
new file mode 100644
diff --git PythonCode/FunctoolsLambda/TheLambda/__init__.py PythonCode/FunctoolsLambda/TheLambda/__init__.py
new file mode 100644
diff --git PythonCode/FunctoolsLambda/DerivedType/DictDerivedType.py PythonCode/FunctoolsLambda/DerivedType/DictDerivedType.py
new file mode 100644
diff --git PythonCode/FunctoolsLambda/TheFunctools/__init__.py PythonCode/FunctoolsLambda/TheFunctools/__init__.py
new file mode 100644
diff --git PythonCode/FunctoolsLambda/DerivedType/__init__.py PythonCode/FunctoolsLambda/DerivedType/__init__.py
new file mode 100644
diff --git PythonCode/FunctoolsLambda/RecursiveFunction/RecursiveFunction.py PythonCode/FunctoolsLambda/RecursiveFunction/RecursiveFunction.py
new file mode 100644
diff --git PythonCode/InterviewQuestions/__init__.py PythonCode/InterviewQuestions/__init__.py
new file mode 100644
diff --git PythonCode/FunctoolsLambda/RecursiveFunction/__init__.py PythonCode/FunctoolsLambda/RecursiveFunction/__init__.py
new file mode 100644
diff --git PythonCode/InterviewQuestions/chaojiying/__init__.py PythonCode/InterviewQuestions/chaojiying/__init__.py
new file mode 100644
diff --git PythonCode/NetworkProgramming/__init__.py PythonCode/NetworkProgramming/__init__.py
new file mode 100644
diff --git PythonCode/NetworkProgramming/TCP/TCP.py PythonCode/NetworkProgramming/TCP/TCP.py
new file mode 100644
diff --git PythonCode/NetworkProgramming/TCP/__init__.py PythonCode/NetworkProgramming/TCP/__init__.py
new file mode 100644
diff --git PythonCode/NetworkProgramming/TCP/TCP_Client.py PythonCode/NetworkProgramming/TCP/TCP_Client.py
new file mode 100644
diff --git PythonCode/NetworkProgramming/TCP/TCP_Service.py PythonCode/NetworkProgramming/TCP/TCP_Service.py
new file mode 100644
diff --git PythonCode/NetworkProgramming/UDP/UDP聊天器.py PythonCode/NetworkProgramming/UDP/UDP聊天器.py
new file mode 100644
diff --git PythonCode/NetworkProgramming/TCP/文件下载器.py PythonCode/NetworkProgramming/TCP/文件下载器.py
new file mode 100644
diff --git PythonCode/NetworkProgramming/UDP/UDP.py PythonCode/NetworkProgramming/UDP/UDP.py
new file mode 100644
diff --git PythonCode/NetworkProgramming/UDP/__init__.py PythonCode/NetworkProgramming/UDP/__init__.py
new file mode 100644
diff --git PythonCode/MultitaskProgramming/__init__.py PythonCode/MultitaskProgramming/__init__.py
new file mode 100644
diff --git PythonCode/MultitaskProgramming/TheThread/TheThreadPool.py PythonCode/MultitaskProgramming/TheThread/TheThreadPool.py
new file mode 100644
diff --git PythonCode/MultitaskProgramming/TheThread/__init__.py PythonCode/MultitaskProgramming/TheThread/__init__.py
new file mode 100644
diff --git PythonCode/MultitaskProgramming/TheProcess/TheMultiprocessing.py PythonCode/MultitaskProgramming/TheProcess/TheMultiprocessing.py
new file mode 100644
diff --git PythonCode/MultitaskProgramming/TheProcess/文件夹copy器(多进程版).py PythonCode/MultitaskProgramming/TheProcess/文件夹copy器(多进程版).py
new file mode 100644
diff --git PythonCode/MultitaskProgramming/TheProcess/TheProcessPool.py PythonCode/MultitaskProgramming/TheProcess/TheProcessPool.py
new file mode 100644
diff --git PythonCode/MultitaskProgramming/TheProcess/__init__.py PythonCode/MultitaskProgramming/TheProcess/__init__.py
new file mode 100644
diff --git PythonCode/Game/Python PythonCode/Game/Python
deleted file mode 100644
index d3f5a12faa99758192ecc4ed3fc22c9249232e86..0000000000000000000000000000000000000000
GIT binary patch
literal 0
Hc$@<O00001

diff --git PythonCode/Def_Function/九九乘法表.xlsx PythonCode/Def_Function/九九乘法表.xlsx
new file mode 100644
index 0000000000000000000000000000000000000000..a28dab61339fedcd502f7688cdeb2c0677b0c182
GIT binary patch
literal 5182
zc$|G$2T)VZw+~eby{U8+q#5ZbT@VQpAp{H<i4=hdp@bG8L69OM(xjs_X#qp8p`&!^
zO+hK5^dizEO7+Fh`Hz2j-+Oy!_s-tg-<fmHJ#7!{It?us001}+C~~}RbWF>@I)Jh(
zrA#);v~{t8xx2V}NZ)aFmBKkY8APfxQp>Vk{n_Q#P^Hy$#aeT~xTK8rKA&`yt#;X!
z2aU>2Pcecnr@&J{JIQGx%Y|V0)0wj|tN`wlp(LnzE`~qRo?wFqs4hhJh4)|6v&w%f
z_>zI}eBR)YB@+C?okg$^2c2Iobw!D_5YEss|8#f$NPMffCc2#<G_tOWwt)S`ZXZf7
zW0kTyPYnRD|2MlfF7Bvb{PxE5JG96!wOgWoq=`eVWMb!sN{8tma$oe6Cygbw`IRWf
zG#>C58}N+NFkz#=E#(@fThL|rv@R^tfaRWH?yA;`z~7e$8?gcO1O~g{c8|Jy8=jgP
zLuaT0;X<4K0~dQQAVi4g^br0gh$l{ql^l|pB0~MRLQ|g~;WhziI;Bh<T?Sll0CRV{
zYf^_`kv|>yl=H4sy2TU1t{4gHpBnEWm+z32<GmazHTC-Q>e2=w1<8|mP2~|@l1D4o
zpU?Bd{+RQc7ps$fGKq*|X`D&5UvsaQw($E=$4jzEZrJIFl%{_y_~4*zo$hblJinbH
z%tj9Yq=*3koRqIPCuyub${F>0mHnliRWqc=m=f26wc-Js9od<&{bB&Ag3|--IbQKR
zXca2-h#e8(gtv_j@_VIwk*zy{c{RqMHd&1pw6xc!qr0%Egx~rqWxW_261R!7`XD_%
zQdcGY@zYH?5q2#Zp4{T~*Fb{4MWq=U(4yqq$;r_&5g2y-I*zM*<n|{due9*Ua>e+h
zX%N~e<CLzgm9GWJUUL9$WaeUdx?)a9{s(tAJOY(P#d%Xpv?iotbH}M|f9#_Ms((pE
zKrR3y!-qKS*XNQu3pES*3~z3I?O=D=)Uji5=$e0Er*9lxtsXgRnESXKv#LreqR-QZ
z+`9TAylV`r;LQ7JW&@{0>K+Pn<){5*RF~GA`pxN8wiZK07J9(;J$bAsIwvpUhT-sc
z->H>k`xIaV(s0<(YjQa9NqgY{j=6Ee@NrAgllJ@p><U^`?4Zaod+CJz74Xc8HwSm+
zoaXRp0K(OCq-TgG!9rs9UL5ZSfx1bp+v|w0%1_u2+uLYI&_g^43SjrtC^{CvrPe`x
zm`|}5DfClw%+T$qk$#Cv81M0<Hv!wafoIw#iVwCE>pHXLy;FTv`W)l@(D_ukt98l!
zvHKp2voCUEM-8s@xz>XiHui*(cOHvjR5{&M`0cLv^pnZagmZHJYdgRdsG6OSX+nv4
zfB$S+xVv!OBpKmLHq^xkj}l*(pB;?@i|D*~bD?&YU8z!!S&sAa@zmgF4lsV|YzEnc
zjNl&??FH<gIDM-ckH49U2>G7xlB9k!1EDt-^n(q|JDuV&?=k4KcZ>iYB%9PvWF;cF
zsS;03DdZ`F+D35kuQv)))C4#=dgB=BwSp5xL^+7c4-Bqx9-b$R9i|LxuE$A>>_VcS
zqRWMIv7)_;^1MypV!nHi?T6I759xMN6oLHFd;-*VeC6OXLFl@5!D5lfq{3$Q^H(&i
zc`ow0SDpwUxe<e`%sAQyanPX(_WfH0im@72Z@%<K-|HKRW?_%9xI{VI7Z%0-N-$Un
zlC+xXhM+x2vuM$4S`6&Idr<u#_?^5HDDu1R+mn!4R?*zcOL7XwvXX8wGz6JCyvTd3
zpz%^r4oJ6ABd9UwjRRgvXs?GA1>UFnIXHHyIsZrCYh^zv-+sbc%{TRop{h&5zIIK+
zVaShQ46=2vNOo*gK}y`_rhD(34tQ~_#CzozufH7FYou+g?tTynDo(m}LHI<}^?-6M
zk?Q@hu64;)hDBTCIficdFzQk$N7@xW%+if*Nc`wragBJj8gh22I0LHz>fcebT&U<}
zl-I6uzrIY0YpfJif_y9OafJ$YGpX9C#R!nR(ghUv$mX82!UUNciQ3h?R~l)YYf~pw
zl+vC>*8qo&qg+~cmfCQ<)5;%cYkZ&GbY6HrIJmdaWK@#1rj{Vk5we+i=4(dqv;G$C
z$N2k}&+OvcVG3N%P6Z+$aFtc{=mv=EldaW-^kWZ;ji@(`O{`>*?KJ13GJW*JbrxM0
z5^r11493ii=b$Pv#S&gT&S#C4o6*lW?ee=mqDq@g1o};on<b47>J{A3{=-{^Z(cC5
zLr*YrT(gNgnFGn(;<?eda9*#~MCp}|Jc%RmRQ=3+ha2=pHHRmOm0GT*PMPS9lC{g(
zoVvio078b`;+QrtUwyZboKoa{)^j(}tI2Bfz_nACbxw7`@|(GK(F5}2%q}KY^_qSP
zzKxv<t3xdu&rg5iq}(j*YfKb9Csl7;=hb!UK-(OC|7W|54Vz3g65M@-8p?h;pohUw
zi=lHIT%jdQbZ1Vw&#bM*I(UVT?t%iGgWz(u?@o4UKWS2zch`OoKetshCd&9|d>Y<c
z$J;1sb-l$KlX^ky=eWgN^@@|~;H|9Zp9ISvdn9{TH|rGqM2raT$W1A`j;nm6v6$xs
zX=guZ@(m63XV158tSvU&IhUeZaepJ=bn^blcs6<R6O+%|d^3XWdG^cKkNF72(A$I~
zzbRNg<+3i!DJ^UtlV!sDBes|_?kY_^)=A=(e-~Du907FEdZ#&edHgN2J(*d7Kbp=$
z_BrWd)+`jLHgUMdT+-Yc`FS<$71iGfM72?Kx{8umM;HNsQ@<04my5fjhdl~~^^pGO
z^-mV@9T~@D$*=(iEVX<z87@}AY0(}_b9V@N@4jjbx9Y*D>>}!x4iCm`OUhQmg)*(0
zdG5DIy5SR+ot1zY51$sTKGwm#-No|hw2;MXy{n_e29qtx#`h{O8r%yBj^)_KTs7w_
z{QwH9tzBx#<6l!J=EbemI(u(q2Yzl?aoF~fFvD8}xhYNJFf6*xE>}(Pd92eqi$b|#
zD6{CWGDnp`)`%}O=g48}NS{5Ws{W^}`%bO+>RJ{j(PHDq5A8D;_P#IvSI?8iz%P48
zg-SV`9ciB5*$;k}u`<-WvLdlN`K+#Uu2QfSLVA^ysv*^UmdVrF@>SLDtu!Ip+1OgD
zB1iL^gqQ`*4{G`Dj?zw3^EEkD+xWq*2^W3c+R%qjPqUoRx(yx+Z~hognzx~@7Vpuy
zlP2DC_0CUSp23(aOt9&tq`IP-Tt`f%Yk?zBR+A^tlxy05K5au3Q~$)SzH_uddWOJ8
z1Gl2A$GB|D%W~jy#Gcr@%R~C==p0e~P=ekWdhxV7c;iq*;EJOGk(R4vcMK+(3STBd
z=ksFmd9my(E|fFJQ~S9IKe9_I%X8q=p?A8m+C(m{4hL^tqLXnWcVb=Ad|J}HsD9+T
zI0{$cb2XV<$J(q5a^fJOk9u2!jU~h*3%{yDQ0W{_g%dX<U&OhDouAO>N_#FIGU-4e
zzqr-t@tgtT23u4yzadH0R=VsY9v=u9cxOPNk5K$75&sZU>YxV81H|uG5IrvWdGzo1
zzG_^Q+R~-)Hfd)XH=TZpT>J~Wjqj-L5h57F7<LUa;q;Pirtj4W?l2xt5I!AFCD}1D
zCrp@62YzEZX`TvPee(T&A&bFf+QRqA_T|YF^~-PPxbSFuJg;F-v9aTah(ukF^%Gqh
zRu87G6LW*rTWhm?wpsr+cAu@R2_uTJlNkU2=HJHdfyFzaJbqdDr0IC*xD49?_h;6Z
zvCkCU^fqDIRv8x<>sWnFtd-dpr@J;|zOASVD|?pb-xBxDH(2lCPp#pz8{W(3=(jtg
zR%egeb@n7T?xidoY=9KjE`NZY(llF9_?}*S<D(aJJx4djbjP7o+@qJ!>B%R**g#fS
z9c%jGOnS39nNxX}1S+@p&$`V>?s|7Izb59GSj(*<LM?a;$gG=RU?XVEevSV6&-2aQ
zFYhE|30;V|XWwHJw7%FxggZd2;&oau!)|Mj<nP0%#ZFCWImKBP3D~;2@7LZ|x0OGm
zcKS_IEx5W)B@10;l)0_xx`}Pitul{H|8Dwl;M#+-;K%%!a3esKZpK^r$VJ`z3wuLl
z?^inL$9qcNCLd>ru*Pz7fBTtRwYc|UvJBd2_7mmrpg-WpG7=^xW`<|jB{V#}{D|er
zgwBfsrbL@$-;UH9<&2)EvNwmq$8KGWkXdt}`JN_ZMO@o&*#TGhzz$K=RUbfpoDuw3
z#Z>R+vi2M0``mWbpxoXd#E`=D*(7iH<PzIedg`kJ(jxUb<j)XcE-`B~t*j(VJXPBh
zkYwLacz;rXm^B=;B2p%*>=?s&OCp=)61P|{@e|~xnTd{30$g`R<++x@b|GjZkqn*-
zW|Cw9@77ri59eH(ol#G}yE_;Riyun9W&-)n8;zZcGBR00-*Ai4G6)zG2!9dzP&Iy@
ziw+v!72*95ot-C6>m}Qeh0??3wyLTNEnkob&4UPs5ah*yz^1Bb@Jl9{V?c?}bpf9(
z^)8nwqR(M&)gJTTwwD-M$N!qL<D}RhCDsBg-BC^+(o(<H)R-C!<^H1S*EWzQb8O&D
zh&*cJ1nmx$X(sD?4!TgC)K|r01h*(g9=y65$AlnSb5$vu6h=ICz-Ej#dsj_$jdboQ
zx-a@l(OZz9;^QIBtK&A>C1xNEO(~wcRSmW$ay_zdhTI-aC8&=}8)~`u7pv&IT|r;F
zF3+;wJLD(#eTzv^XAUA9kL1M-&mDSx(i_Y;i#U;_(>a_eK=2djAV&=^72BMx@J24~
zxY@&jkrOuO!riPZ4iy7CS-(60{4J;gtUXwU3II4u5tQ{$MzMBras1_G5k`ZM7EQMO
zcvm4S<H10}Qkc$#kQ3*9Ux_5&U7B=$KVC6b>=nxf`Y}EHu@BVJGqI`f0}6@kO!PW4
zpTmwmiRSI5uaCI&_6jUVlx&Kf)8<9eBiraT>#w_%JEeJtH5DYpjwB4PJfekY0fFS#
zf}i>Qb{-f&PnBvu-b_vYy!u*1kjA@SGd{UTq%>oTQPx5{<X&A&XU#+p*qRlDI1KP=
z=rlyOQn4d_5Q;I$_?$pR_qfm2169i#wBBl%)B#QvDhp(QT~1M(>mo`)$D7+`@lKM>
z6UIZs2>2+XIjO5pJE~Ndew2@?wCQ4!2!geS2SmnWo$_RpUlQ|kZ~>6@9NtxfG|88;
zn%g;YMsBOQ6YfJ#wHC-<ACS}4v3=^2WI>Bg(;KZz_f0SVty~eo<jg|K?gvG|yuX$E
z+mQZS#s3&pWwbiWLm8$=#T;`0MHo?=PTw4HUW$!wOPGVBtq52p{fH_`1$(C~?SkK0
zC-j9qmlr0Tv?T&|r0=rr{;~$hMplGM_07l_I-D$+z7<SgKh)sB79(D(^<LgK?d$W*
z6tzQb?7c~}kJ3Sz(mJb5z4;<h$5sNu%{!~#Y)`t_WIWxipOE=djwe(y!PV^abmwVj
zw5e~2A+%xvfAZ3Ioub|uhN3AZR~+{6NKJx@!pHDX1nj5zeW^uiyI`;=4Av5kcSU)a
z{}Qn<)&SZf!$y$~g*+z(LZs*LSuvWsQrQ^t<{!q|nGKE0L&qTL9Ndo#3UD9m`_mE&
zK0akHSxnu2A17es!$oa!3~DWK7FSepMp<t^iF6iH8H;55-aYpa*2Ia+6Tcs~@=m_O
z-Gzu-!t)ud8$5q)eM>E(xyJ#*lcfmZ7;S4>5sF*B`m)Ajz{>8d6ap5SA9Q<1z;*e)
zswM=iT^jwwf?yNBSg5ID_S$=Fx{F79oR?1JWy4GYuMIV^l;*VE${<$OKr~Gzyua?l
ze$!pxn=S(&yK*V5Uq`BN=cI|P@HN|<V%(Xs?Js*;P~^kL=-!zFCiJD*0Bgj2|Bw6a
zCx7zwZLl|geRa9Cegw+vHy`%-vV|W-lT_4Pfd9MK^Pk~Q1^AcF&r$Tz*2^Ds@xL`<
zj>3<2C;q^@ss6QBag@N(>hwQ@6u@-+|E^V!QaPIT|FE$GJW>Q4g&vLCf1vl6|BB&9
zfk&g@AD{)x|B8u6!AHIP54eu?|MU5ybdEaGA3Eu5|LRt->vZ(L4lqz24GQPW|NQj-
E0i+@NQUCw|

